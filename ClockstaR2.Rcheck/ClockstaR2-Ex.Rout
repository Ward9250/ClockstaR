
R version 3.0.2 (2013-09-25) -- "Frisbee Sailing"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin10.8.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ClockstaR2"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ClockstaR2')
Loading required package: ape
Loading required package: cluster
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ClockstaR2-package")
> ### * ClockstaR2-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ClockstaR2-package
> ### Title: ClockstaR: choosing the number of relaxed-clock models in
> ###   molecular phylogenetic analysis
> ### Aliases: ClockstaR2-package ClockstaR2
> ### Keywords: molecular-clock
> 
> ### ** Examples
> 
> 
> 
> # Create a list of trees of class multiPhylo with four patterns of among-lineage rate variation 
> tr.fix <- rtree(10)
> 
> set.seed(12345)
> rates1 <- abs(rnorm(18, sd = 0.1))
> set.seed(123456)
> rates2 <- abs(rnorm(18, sd = 0.1))
> set.seed(1234567)
> rates3 <- abs(rnorm(18, sd = 0.1))
> set.seed(12345678)
> rates4 <- abs(rnorm(18, sd = 0.1))
> 
> trees.list <- list()
> 
> for(i in 1:20){
+       trees.list[[i]] <- tr.fix
+       if(i <= 5){
+       	   trees.list[[i]]$edge.length <- abs(rates1 + rnorm(18, 0, 0.01)) 
+       }else if(i > 5 && i <= 10){
+       	    trees.list[[i]]$edge.length <- abs(rates2 + rnorm(18, 0, 0.01)) 
+       }else if(i >= 10 && i < 15){
+       	    trees.list[[i]]$edge.length <- abs(rates3 + rnorm(18, 0, 0.01))  
+       }else{
+ 	    trees.list[[i]]$edge.length <- abs(rates4 + rnorm(18, 0, 0.01)) 
+       }
+ }
> 
> names(trees.list) <- paste0("tree", 1:20)
> class(trees.list) <- "multiPhylo"
> 
> # Estimate sBSDmin distance for all pairs of trees:
> trees.bsd <- bsd.matrix(trees.list)
[1] "Estimating tree distances"
[1] "estimating distances 1 of 19"
[1] "estimating distances 2 of 19"
[1] "estimating distances 3 of 19"
[1] "estimating distances 4 of 19"
[1] "estimating distances 5 of 19"
[1] "estimating distances 6 of 19"
[1] "estimating distances 7 of 19"
[1] "estimating distances 8 of 19"
[1] "estimating distances 9 of 19"
[1] "estimating distances 10 of 19"
[1] "estimating distances 11 of 19"
[1] "estimating distances 12 of 19"
[1] "estimating distances 13 of 19"
[1] "estimating distances 14 of 19"
[1] "estimating distances 15 of 19"
[1] "estimating distances 16 of 19"
[1] "estimating distances 17 of 19"
[1] "estimating distances 18 of 19"
[1] "estimating distances 19 of 19"
> 
> # Find the optimal number of partitions:
> partitions.object <- partitions(trees.bsd)
> 
> # plot partitions in two graphics devices
> plot(partitions.object)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("bsd.dist")
> ### * bsd.dist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bsd.dist
> ### Title: Estimate sBSDmin distnace between a pair of trees
> ### Aliases: bsd.dist
> ### Keywords: relaxed-clock
> 
> ### ** Examples
> 
> ##---- Should be DIRECTLY executable !! ----
> ##-- ==>  Define data, use random,
> ##--	or do  help(data=index)  for the standard data sets.
> 
> # Simulate two trees with identical topologies, but different patterns of among lineage rate variation
> 
> tr1 <- rtree(10)
> 
> tr2 <- tr1
> tr2$edge.length <- sample(tr1$edge.length)
> 
> par(mfrow = c(1, 2))
> plot(tr1)
> plot(tr2)
> 
> bsd.dist(tr1, tr2)
min.bdi.scaled scaling.factor        min.bdi 
  5.548515e-10   1.000000e+00   5.432390e-09 
> 
> 
> ## The function is currently defined as
> function (tree1, tree2) 
+ {
+     list.tr <- list()
+     list.tr[[1]] <- tree1
+     list.tr[[2]] <- tree2
+     lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
+     tree1 <- list.tr[lens == max(lens)][[1]]
+     tree2 <- list.tr[lens == min(lens)][[1]]
+     tree.dist.opt <- function(x) {
+         tree3 <- tree2
+         tree3$edge.length <- tree2$edge.length * x
+         return(dist.topo(tree1, tree3, method = "score"))
+     }
+     opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
+         lower = 0, upper = 50)
+     min.bdi <- opt.dist$value
+     scaling <- opt.dist$par
+     tree2.scaled <- tree2
+     tree2.scaled$edge.length <- tree2$edge.length * scaling
+     root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
+         1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
+         1e-05]))
+     tree1.root.scaled <- tree1
+     tree2.root.scaled <- tree2.scaled
+     tree1.root.scaled$edge.length <- tree1$edge.length * root.scaling
+     tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
+         root.scaling
+     min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
+         method = "score")
+     res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
+     names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
+         "min.bdi")
+     return(res.vect)
+   }
function (tree1, tree2) 
{
    list.tr <- list()
    list.tr[[1]] <- tree1
    list.tr[[2]] <- tree2
    lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
    tree1 <- list.tr[lens == max(lens)][[1]]
    tree2 <- list.tr[lens == min(lens)][[1]]
    tree.dist.opt <- function(x) {
        tree3 <- tree2
        tree3$edge.length <- tree2$edge.length * x
        return(dist.topo(tree1, tree3, method = "score"))
    }
    opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
        lower = 0, upper = 50)
    min.bdi <- opt.dist$value
    scaling <- opt.dist$par
    tree2.scaled <- tree2
    tree2.scaled$edge.length <- tree2$edge.length * scaling
    root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
        1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
        1e-05]))
    tree1.root.scaled <- tree1
    tree2.root.scaled <- tree2.scaled
    tree1.root.scaled$edge.length <- tree1$edge.length * root.scaling
    tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
        root.scaling
    min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
        method = "score")
    res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
    names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
        "min.bdi")
    return(res.vect)
}
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("bsd.matrix")
> ### * bsd.matrix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bsd.matrix
> ### Title: Estimate the sBSDmin distance for all pairs of trees in a list
> ### Aliases: bsd.matrix
> ### Keywords: sBSDmin
> 
> ### ** Examples
> 
> 
> 
> # Create a list of trees of class multiPhylo with four patterns of among-lineage rate variation 
> tr.fix <- rtree(10)
> 
> set.seed(12345)
> rates1 <- abs(rnorm(18, sd = 0.1))
> set.seed(123456)
> rates2 <- abs(rnorm(18, sd = 0.1))
> set.seed(1234567)
> rates3 <- abs(rnorm(18, sd = 0.1))
> set.seed(12345678)
> rates4 <- abs(rnorm(18, sd = 0.1))
> 
> trees.list <- list()
> 
> for(i in 1:20){
+       trees.list[[i]] <- tr.fix
+       if(i <= 5){
+       	   trees.list[[i]]$edge.length <- abs(rates1 + rnorm(18, 0, 0.01)) 
+       }else if(i > 5 && i <= 10){
+       	    trees.list[[i]]$edge.length <- abs(rates2 + rnorm(18, 0, 0.01)) 
+       }else if(i >= 10 && i < 15){
+       	    trees.list[[i]]$edge.length <- abs(rates3 + rnorm(18, 0, 0.01))  
+       }else{
+ 	    trees.list[[i]]$edge.length <- abs(rates4 + rnorm(18, 0, 0.01)) 
+       }
+ }
> 
> names(trees.list) <- paste0("tree", 1:20)
> class(trees.list) <- "multiPhylo"
> 
> # Estimate sBSDmin distance for all pairs of trees:
> trees.bsd <- bsd.matrix(trees.list)
[1] "Estimating tree distances"
[1] "estimating distances 1 of 19"
[1] "estimating distances 2 of 19"
[1] "estimating distances 3 of 19"
[1] "estimating distances 4 of 19"
[1] "estimating distances 5 of 19"
[1] "estimating distances 6 of 19"
[1] "estimating distances 7 of 19"
[1] "estimating distances 8 of 19"
[1] "estimating distances 9 of 19"
[1] "estimating distances 10 of 19"
[1] "estimating distances 11 of 19"
[1] "estimating distances 12 of 19"
[1] "estimating distances 13 of 19"
[1] "estimating distances 14 of 19"
[1] "estimating distances 15 of 19"
[1] "estimating distances 16 of 19"
[1] "estimating distances 17 of 19"
[1] "estimating distances 18 of 19"
[1] "estimating distances 19 of 19"
> 
> 
> ## The function is currently defined as
> function (tree.list) 
+ {
+     d.mat <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
+     rownames(d.mat) <- names(tree.list)
+     colnames(d.mat) <- names(tree.list)
+     s.mat <- d.mat
+     print("Estimating tree distances")
+     if (length(tree.list) > 3) {
+         d.mat.lin <- vector()
+         d.mat.lin <- sapply(2:nrow(d.mat), function(a) {
+             print(paste("estimating distances", a - 1, "of", 
+                 nrow(d.mat) - 1))
+             lapply(tree.list[1:(a - 1)], function(y) {
+                 bsd.dist(tree1 = y, tree2 = tree.list[[a]])
+             })
+         })
+         for (a in 1:length(d.mat.lin)) {
+             vec.temp.dist <- vector()
+             vec.temp.scale <- vector()
+             for (b in 1:length(d.mat.lin[[a]])) {
+                 vec.temp.dist[b] <- d.mat.lin[[a]][[b]][1]
+                 vec.temp.scale[b] <- d.mat.lin[[a]][[b]][2]
+             }
+             d.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.dist
+             s.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.scale
+         }
+     }
+     else if (length(tree.list) <= 3) {
+         stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
+     }
+     d.mat.lin <- bsd.dist(tree.list[[1]], tree.list[[2]])
+     d.mat[2, 1] <- d.mat.lin[1]
+     s.mat[2, 1] <- d.mat.lin[2]
+     res.list <- list()
+     res.list[[1]] <- as.dist(d.mat)
+     res.list[[2]] <- s.mat
+     class(res.list) <- "bsd"
+     return(res.list)
+   }
function (tree.list) 
{
    d.mat <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
    rownames(d.mat) <- names(tree.list)
    colnames(d.mat) <- names(tree.list)
    s.mat <- d.mat
    print("Estimating tree distances")
    if (length(tree.list) > 3) {
        d.mat.lin <- vector()
        d.mat.lin <- sapply(2:nrow(d.mat), function(a) {
            print(paste("estimating distances", a - 1, "of", 
                nrow(d.mat) - 1))
            lapply(tree.list[1:(a - 1)], function(y) {
                bsd.dist(tree1 = y, tree2 = tree.list[[a]])
            })
        })
        for (a in 1:length(d.mat.lin)) {
            vec.temp.dist <- vector()
            vec.temp.scale <- vector()
            for (b in 1:length(d.mat.lin[[a]])) {
                vec.temp.dist[b] <- d.mat.lin[[a]][[b]][1]
                vec.temp.scale[b] <- d.mat.lin[[a]][[b]][2]
            }
            d.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.dist
            s.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.scale
        }
    }
    else if (length(tree.list) <= 3) {
        stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
    }
    d.mat.lin <- bsd.dist(tree.list[[1]], tree.list[[2]])
    d.mat[2, 1] <- d.mat.lin[1]
    s.mat[2, 1] <- d.mat.lin[2]
    res.list <- list()
    res.list[[1]] <- as.dist(d.mat)
    res.list[[2]] <- s.mat
    class(res.list) <- "bsd"
    return(res.list)
}
> 
> 
> 
> cleanEx()
> nameEx("bsd.matrix.para")
> ### * bsd.matrix.para
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bsd.matrix.para
> ### Title: Estimate the sBSDmin distance for all pairs of trees in a list
> ###   with parallelisation.
> ### Aliases: bsd.matrix.para
> ### Keywords: sBSDmin
> 
> ### ** Examples
> 
> 
> # Create a list of trees of class multiPhylo with four patterns of among-lineage rate variation 
> tr.fix <- rtree(10)
> 
> set.seed(12345)
> rates1 <- abs(rnorm(18, sd = 0.1))
> set.seed(123456)
> rates2 <- abs(rnorm(18, sd = 0.1))
> set.seed(1234567)
> rates3 <- abs(rnorm(18, sd = 0.1))
> set.seed(12345678)
> rates4 <- abs(rnorm(18, sd = 0.1))
> 
> trees.list <- list()
> 
> for(i in 1:20){
+       trees.list[[i]] <- tr.fix
+       if(i <= 5){
+       	   trees.list[[i]]$edge.length <- abs(rates1 + rnorm(18, 0, 0.01)) 
+       }else if(i > 5 && i <= 10){
+       	    trees.list[[i]]$edge.length <- abs(rates2 + rnorm(18, 0, 0.01)) 
+       }else if(i >= 10 && i < 15){
+       	    trees.list[[i]]$edge.length <- abs(rates3 + rnorm(18, 0, 0.01))  
+       }else{
+ 	    trees.list[[i]]$edge.length <- abs(rates4 + rnorm(18, 0, 0.01)) 
+       }
+ }
> 
> names(trees.list) <- paste0("tree", 1:20)
> class(trees.list) <- "multiPhylo"
> 
> ## Not run: 
> ##D # Estimate sBSDmin distance for all pairs of trees:
> ##D trees.bsd <- bsd.matrix.para(trees.list, para = T, ncore = 2)
> ## End(Not run)
> 
> 
> ## The function is currently defined as
> function (tree.list, para = F, ncore = 1) 
+ {
+ require(foreach)
+ require(doParallel)
+ 
+     if (length(tree.list) <= 3) {
+         stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
+     }
+     bsd.dist <- function(tree1, tree2) {
+         list.tr <- list()
+         list.tr[[1]] <- tree1
+         list.tr[[2]] <- tree2
+         lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
+         tree1 <- list.tr[lens == max(lens)][[1]]
+         tree2 <- list.tr[lens == min(lens)][[1]]
+         tree.dist.opt <- function(x) {
+             tree3 <- tree2
+             tree3$edge.length <- tree2$edge.length * x
+             return(dist.topo(tree1, tree3, method = "score"))
+         }
+         opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
+             lower = 0, upper = 50)
+         min.bdi <- opt.dist$value
+         scaling <- opt.dist$par
+         tree2.scaled <- tree2
+         tree2.scaled$edge.length <- tree2$edge.length * scaling
+         root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
+             1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
+             1e-05]))
+         tree1.root.scaled <- tree1
+         tree2.root.scaled <- tree2.scaled
+         tree1.root.scaled$edge.length <- tree1$edge.length * 
+             root.scaling
+         tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
+             root.scaling
+         min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
+             method = "score")
+         res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
+         names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
+             "min.bdi")
+         return(res.vect)
+     }
+     sub.trees <- list()
+     for (k in 2:length(tree.list)) {
+         sub.trees[[k]] <- tree.list[1:k - 1]
+     }
+     compute.tree.dists <- function(tree.sub.list, fix.tree) {
+         res <- sapply(tree.sub.list, function(a) {
+             return(bsd.dist(fix.tree, a))
+         })
+         return(res)
+     }
+     if (para == T) {
+         cl <- makeCluster(ncore)
+         registerDoParallel(cl)
+         print(paste("Clusters registered as follows: ", cl))
+         res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
+             .packages = "ape") %dopar% compute.tree.dists(tree.sub.list = s.trees, 
+             fix.tree = tree.list[[j]])
+         stopCluster(cl)
+     }
+     else if (para == F) {
+         res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
+             .packages = "ape") %do% compute.tree.dists(tree.sub.list = s.trees, 
+             tree.list[[j]])
+     }
+     res.list <- list()
+     res.list[[1]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
+     for (m in 2:nrow(res.list[[1]])) {
+         res.list[[1]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][1, 
+             ]
+     }
+     rownames(res.list[[1]]) <- names(tree.list)
+     colnames(res.list[[1]]) <- names(tree.list)
+     res.list[[1]] <- as.dist(res.list[[1]])
+     res.list[[2]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
+     for (m in 2:nrow(res.list[[2]])) {
+         res.list[[2]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][2, 
+             ]
+     }
+     rownames(res.list[[2]]) <- names(tree.list)
+     colnames(res.list[[2]]) <- names(tree.list)
+     class(res.list) <- "bsd"
+     return(res.list)
+   }
function (tree.list, para = F, ncore = 1) 
{
    require(foreach)
    require(doParallel)
    if (length(tree.list) <= 3) {
        stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
    }
    bsd.dist <- function(tree1, tree2) {
        list.tr <- list()
        list.tr[[1]] <- tree1
        list.tr[[2]] <- tree2
        lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
        tree1 <- list.tr[lens == max(lens)][[1]]
        tree2 <- list.tr[lens == min(lens)][[1]]
        tree.dist.opt <- function(x) {
            tree3 <- tree2
            tree3$edge.length <- tree2$edge.length * x
            return(dist.topo(tree1, tree3, method = "score"))
        }
        opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
            lower = 0, upper = 50)
        min.bdi <- opt.dist$value
        scaling <- opt.dist$par
        tree2.scaled <- tree2
        tree2.scaled$edge.length <- tree2$edge.length * scaling
        root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
            1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
            1e-05]))
        tree1.root.scaled <- tree1
        tree2.root.scaled <- tree2.scaled
        tree1.root.scaled$edge.length <- tree1$edge.length * 
            root.scaling
        tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
            root.scaling
        min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
            method = "score")
        res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
        names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
            "min.bdi")
        return(res.vect)
    }
    sub.trees <- list()
    for (k in 2:length(tree.list)) {
        sub.trees[[k]] <- tree.list[1:k - 1]
    }
    compute.tree.dists <- function(tree.sub.list, fix.tree) {
        res <- sapply(tree.sub.list, function(a) {
            return(bsd.dist(fix.tree, a))
        })
        return(res)
    }
    if (para == T) {
        cl <- makeCluster(ncore)
        registerDoParallel(cl)
        print(paste("Clusters registered as follows: ", cl))
        res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
            .packages = "ape") %dopar% compute.tree.dists(tree.sub.list = s.trees, 
            fix.tree = tree.list[[j]])
        stopCluster(cl)
    }
    else if (para == F) {
        res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
            .packages = "ape") %do% compute.tree.dists(tree.sub.list = s.trees, 
            tree.list[[j]])
    }
    res.list <- list()
    res.list[[1]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
    for (m in 2:nrow(res.list[[1]])) {
        res.list[[1]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][1, 
            ]
    }
    rownames(res.list[[1]]) <- names(tree.list)
    colnames(res.list[[1]]) <- names(tree.list)
    res.list[[1]] <- as.dist(res.list[[1]])
    res.list[[2]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
    for (m in 2:nrow(res.list[[2]])) {
        res.list[[2]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][2, 
            ]
    }
    rownames(res.list[[2]]) <- names(tree.list)
    colnames(res.list[[2]]) <- names(tree.list)
    class(res.list) <- "bsd"
    return(res.list)
}
> 
> 
> 
> cleanEx()
> nameEx("clockstar.interactive")
> ### * clockstar.interactive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clockstar.interactive
> ### Title: Run clockstar interactively
> ### Aliases: clockstar.interactive
> ### Keywords: gene-tree molecular-clock sBSDmin
> 
> ### ** Examples
> 
> ## Not run: 
> ##D clockstar.interactive()
> ## End(Not run)
> 
> ## The function is currently defined as
> function () 
+ {
+     print("Welcome to ClockstaR2")
+     trees.file <- readline("please drag or type in the path to your gene trees file in NEWICK format:\n")
+     print(paste("reading trees from file: ", trees.file))
+     trees <- read.tree(trees.file)
+     print(paste("I read", length(trees), "from your file"))
+     if (length(names(trees) > 0)) {
+         print(paste("The names of your trees are:"))
+         print(names(trees))
+     }
+     else {
+         warning("These trees have no names")
+     }
+     if (("foreach" %in% installed.packages()[, 1]) && "doParallel" %in% 
+         installed.packages()[, 1]) {
+         print("Packages foreach and doParallel are available for parallel computation")
+         para <- readline("Should we run ClockstaR in parallel (y / n)? (This is good for large data sets)\n")
+         if (para == "y") {
+             require(foreach)
+             require(doParallel)
+             ncore <- as.integer(readline("How many cores should ClockstaR use (integer):\n"))
+             print(paste("running ClockstaR in parallel with", 
+                 ncore, "cores"))
+             trees.bsd <- bsd.matrix.para(trees, para = T, ncore = ncore)
+         }
+         else {
+             print("Calculating sBSDmin distances between all pairs of trees")
+             trees.bsd <- bsd.matrix(trees)
+         }
+     }
+     else {
+         print("Calculating sBSDmin distances between all pairs of trees")
+         trees.bsd <- bsd.matrix(trees)
+     }
+     print("I finished calculating the sBSDmin distances between trees\n")
+     default.run <- readline("The settings for clustering with ClockstaR are:\nPAM clustering algorithm\nK from 1 to number of data subsets-1\nSEmax criterion to select the optimal k\n500 bootstrap replicates\n Are these correct? (y/n)\n")
+     if (default.run == "y") {
+         part.data <- partitions(trees.bsd)
+     }
+     else {
+         fun.cluster <- "d"
+         while (!(fun.cluster %in% c("1", "2", "3"))) {
+             fun.cluster <- readline("Please select one of the clustering functions bellow:(1-3)\n(1) PAM\n(2) CLARA\n(3) FANNY\n (See the user manual for package cluster for more details\n")
+         }
+         if (fun.cluster == "1") {
+             fun <- pam
+         }
+         else if (fun.cluster == "2") {
+             fun <- clara
+         }
+         else if (fun.cluster == "3") {
+             fun <- fanny
+         }
+         max.k <- as.numeric(readline("What should be the maximum k to test (the maximum is the number of data subsets - 1)\n"))
+         if (max.k >= ncol(trees.bsd[[2]])) {
+             stop("The maximun k should be between 1 and the number of data sets - 1. ABORTING")
+         }
+         criterion <- readline("Please type in the criterion to select the optimal k (This can be firstSEmax, Tibs2001max, globalSEmax, firstmax, or globalmax)\n")
+         while (!(criterion %in% c("firstSEmax", "Tibs2001max", 
+             "globalSEmax", "firstmax", "globalmax"))) {
+             criterion <- readline("You have not selected any of the available criteria. Please select again")
+         }
+         boot.n <- as.numeric(readline("How many boostrap replicates should be run for the Gap statistic?\n"))
+         print("The settings for clustering are complete. The settings are:\n")
+         print("cluster function, maximum k, criterion")
+         print(c(c("PAM", "CLARA", "FANNY")[as.numeric(fun.cluster)], 
+             max.k, criterion))
+         part.data <- partitions(trees.bsd, FUN = fun, kmax = max.k, 
+             B = boot.n, gap.best = criterion)
+     }
+     print("ClockstaR has finished running")
+     print(paste("The best number of partitions for your data set is:", 
+         part.data$best.k))
+     save.dat <- readline("Do you wish to save the results in a pdf file?(y/n)\n")
+     if (save.dat == "y") {
+         fil.name <- readline("What should be the name and path of the output file?\n")
+         plot.partitions(part.data, save.plot = T, file.name = fil.name)
+     }
+     else {
+         print("please see the results in the active graphics devices")
+         plot.partitions(part.data)
+     }
+     return(part.data)
+   }
function () 
{
    print("Welcome to ClockstaR2")
    trees.file <- readline("please drag or type in the path to your gene trees file in NEWICK format:\n")
    print(paste("reading trees from file: ", trees.file))
    trees <- read.tree(trees.file)
    print(paste("I read", length(trees), "from your file"))
    if (length(names(trees) > 0)) {
        print(paste("The names of your trees are:"))
        print(names(trees))
    }
    else {
        warning("These trees have no names")
    }
    if (("foreach" %in% installed.packages()[, 1]) && "doParallel" %in% 
        installed.packages()[, 1]) {
        print("Packages foreach and doParallel are available for parallel computation")
        para <- readline("Should we run ClockstaR in parallel (y / n)? (This is good for large data sets)\n")
        if (para == "y") {
            require(foreach)
            require(doParallel)
            ncore <- as.integer(readline("How many cores should ClockstaR use (integer):\n"))
            print(paste("running ClockstaR in parallel with", 
                ncore, "cores"))
            trees.bsd <- bsd.matrix.para(trees, para = T, ncore = ncore)
        }
        else {
            print("Calculating sBSDmin distances between all pairs of trees")
            trees.bsd <- bsd.matrix(trees)
        }
    }
    else {
        print("Calculating sBSDmin distances between all pairs of trees")
        trees.bsd <- bsd.matrix(trees)
    }
    print("I finished calculating the sBSDmin distances between trees\n")
    default.run <- readline("The settings for clustering with ClockstaR are:\nPAM clustering algorithm\nK from 1 to number of data subsets-1\nSEmax criterion to select the optimal k\n500 bootstrap replicates\n Are these correct? (y/n)\n")
    if (default.run == "y") {
        part.data <- partitions(trees.bsd)
    }
    else {
        fun.cluster <- "d"
        while (!(fun.cluster %in% c("1", "2", "3"))) {
            fun.cluster <- readline("Please select one of the clustering functions bellow:(1-3)\n(1) PAM\n(2) CLARA\n(3) FANNY\n (See the user manual for package cluster for more details\n")
        }
        if (fun.cluster == "1") {
            fun <- pam
        }
        else if (fun.cluster == "2") {
            fun <- clara
        }
        else if (fun.cluster == "3") {
            fun <- fanny
        }
        max.k <- as.numeric(readline("What should be the maximum k to test (the maximum is the number of data subsets - 1)\n"))
        if (max.k >= ncol(trees.bsd[[2]])) {
            stop("The maximun k should be between 1 and the number of data sets - 1. ABORTING")
        }
        criterion <- readline("Please type in the criterion to select the optimal k (This can be firstSEmax, Tibs2001max, globalSEmax, firstmax, or globalmax)\n")
        while (!(criterion %in% c("firstSEmax", "Tibs2001max", 
            "globalSEmax", "firstmax", "globalmax"))) {
            criterion <- readline("You have not selected any of the available criteria. Please select again")
        }
        boot.n <- as.numeric(readline("How many boostrap replicates should be run for the Gap statistic?\n"))
        print("The settings for clustering are complete. The settings are:\n")
        print("cluster function, maximum k, criterion")
        print(c(c("PAM", "CLARA", "FANNY")[as.numeric(fun.cluster)], 
            max.k, criterion))
        part.data <- partitions(trees.bsd, FUN = fun, kmax = max.k, 
            B = boot.n, gap.best = criterion)
    }
    print("ClockstaR has finished running")
    print(paste("The best number of partitions for your data set is:", 
        part.data$best.k))
    save.dat <- readline("Do you wish to save the results in a pdf file?(y/n)\n")
    if (save.dat == "y") {
        fil.name <- readline("What should be the name and path of the output file?\n")
        plot.partitions(part.data, save.plot = T, file.name = fil.name)
    }
    else {
        print("please see the results in the active graphics devices")
        plot.partitions(part.data)
    }
    return(part.data)
}
> 
> 
> 
> cleanEx()
> nameEx("optim.trees.interactive")
> ### * optim.trees.interactive
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optim.trees.interactive
> ### Title: Optimise the branch lengths of gene trees interactively
> ### Aliases: optim.trees.interactive
> 
> ### ** Examples
> 
> ## Not run: 
> ##D optim.trees.interactive() # Follow the instructions in the prompt
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("partitions")
> ### * partitions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: partitions
> ### Title: function partitions applied to objects of class bsd
> ### Aliases: partitions
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D 
> ##D tr.fix <- rtree(10)
> ##D 
> ##D set.seed(12345)
> ##D rates1 <- abs(rnorm(18, sd = 0.1))
> ##D set.seed(123456)
> ##D rates2 <- abs(rnorm(18, sd = 0.1))
> ##D set.seed(1234567)
> ##D rates3 <- abs(rnorm(18, sd = 0.1))
> ##D set.seed(12345678)
> ##D rates4 <- abs(rnorm(18, sd = 0.1))
> ##D 
> ##D trees.list <- list()
> ##D 
> ##D for(i in 1:20){
> ##D       trees.list[[i]] <- tr.fix
> ##D       if(i <= 5){
> ##D       	   trees.list[[i]]$edge.length <- abs(rates1 + rnorm(18, 0, 0.01)) 
> ##D       }else if(i > 5 && i <= 10){
> ##D       	    trees.list[[i]]$edge.length <- abs(rates2 + rnorm(18, 0, 0.01)) 
> ##D       }else if(i >= 10 && i < 15){
> ##D       	    trees.list[[i]]$edge.length <- abs(rates3 + rnorm(18, 0, 0.01))  
> ##D       }else{
> ##D 	    trees.list[[i]]$edge.length <- abs(rates4 + rnorm(18, 0, 0.01)) 
> ##D       }
> ##D }
> ##D 
> ##D names(trees.list) <- paste0("tree", 1:20)
> ##D class(trees.list) <- "multiPhylo"
> ##D 
> ##D # Estimate sBSDmin distance for all pairs of trees:
> ##D trees.bsd <- bsd.matrix(trees.list)
> ##D 
> ##D partitions(trees.bsd)
> ##D 
> ##D 
> ## End(Not run)
> 
> ## The function is currently defined as
> function (bsd.object, ...) 
+ UseMethod("partitions")
function (bsd.object, ...) 
UseMethod("partitions")
> 
> 
> 
> cleanEx()
> nameEx("partitions.bsd")
> ### * partitions.bsd
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: partitions.bsd
> ### Title: Obtain optimal partitioning scheme
> ### Aliases: partitions.bsd
> ### Keywords: clustering gap statistic
> 
> ### ** Examples
> 
> 
> 
> # Create a list of trees of class multiPhylo with four patterns of among-lineage rate variation 
> tr.fix <- rtree(10)
> 
> set.seed(12345)
> rates1 <- abs(rnorm(18, sd = 0.1))
> set.seed(123456)
> rates2 <- abs(rnorm(18, sd = 0.1))
> set.seed(1234567)
> rates3 <- abs(rnorm(18, sd = 0.1))
> set.seed(12345678)
> rates4 <- abs(rnorm(18, sd = 0.1))
> 
> trees.list <- list()
> 
> for(i in 1:20){
+       trees.list[[i]] <- tr.fix
+       if(i <= 5){
+       	   trees.list[[i]]$edge.length <- abs(rates1 + rnorm(18, 0, 0.01)) 
+       }else if(i > 5 && i <= 10){
+       	    trees.list[[i]]$edge.length <- abs(rates2 + rnorm(18, 0, 0.01)) 
+       }else if(i >= 10 && i < 15){
+       	    trees.list[[i]]$edge.length <- abs(rates3 + rnorm(18, 0, 0.01))  
+       }else{
+ 	    trees.list[[i]]$edge.length <- abs(rates4 + rnorm(18, 0, 0.01)) 
+       }
+ }
> 
> names(trees.list) <- paste0("tree", 1:20)
> class(trees.list) <- "multiPhylo"
> 
> # Estimate sBSDmin distance for all pairs of trees:
> trees.bsd <- bsd.matrix(trees.list)
[1] "Estimating tree distances"
[1] "estimating distances 1 of 19"
[1] "estimating distances 2 of 19"
[1] "estimating distances 3 of 19"
[1] "estimating distances 4 of 19"
[1] "estimating distances 5 of 19"
[1] "estimating distances 6 of 19"
[1] "estimating distances 7 of 19"
[1] "estimating distances 8 of 19"
[1] "estimating distances 9 of 19"
[1] "estimating distances 10 of 19"
[1] "estimating distances 11 of 19"
[1] "estimating distances 12 of 19"
[1] "estimating distances 13 of 19"
[1] "estimating distances 14 of 19"
[1] "estimating distances 15 of 19"
[1] "estimating distances 16 of 19"
[1] "estimating distances 17 of 19"
[1] "estimating distances 18 of 19"
[1] "estimating distances 19 of 19"
> 
> # Find the optimal number of partitions:
> partitions.object <- partitions(trees.bsd)
> 
> # plot partitions in two graphics devices
> plot(partitions.object)
dev.new(): using pdf(file="Rplots1.pdf")
> 
> 
> 
> 
> 
> ## The function is currently defined as
> function (bsd.object, FUN = pam, find.best = T, B = 500, gap.best = "firstSEmax", 
+     kmax = "", ...) 
+ {
+     dimat <- as.matrix(bsd.object[[1]])
+     if (kmax == "") {
+         kmax <- nrow(dimat) - 1
+     }
+     if (find.best == T) {
+         clusdat <- clusGap(dimat, B = B, FUNcluster = FUN, K.max = kmax)
+         npart <- maxSE(f = clusdat$Tab[, 3], SE.f = clusdat$Tab[, 
+             4], method = gap.best)
+     }
+     parts.list <- list()
+     for (i in 1:kmax) {
+         clus.temp <- FUN(dimat, k = i, ...)
+         parts.list[[i]] <- clus.temp$clustering
+     }
+     parts.mat <- do.call("cbind", parts.list)
+     rownames(parts.mat) <- rownames(dimat)
+     colnames(parts.mat) <- paste0("k=", 1:ncol(parts.mat))
+     res <- list(parts.mat, range(bsd.object[[1]]))
+     names(res) <- c("parts.mat", "range.bsd")
+     if (exists("npart")) {
+         colnames(res[[1]])[npart] <- paste0(colnames(parts.mat)[npart], 
+             "BEST")
+         res[[3]] <- npart
+         names(res)[3] <- "best.k"
+     }
+     if (find.best == T) {
+         res[[4]] <- clusdat
+         names(res)[4] <- "clusterdata"
+     }
+     class(res) <- "partitions"
+     return(res)
+   }
function (bsd.object, FUN = pam, find.best = T, B = 500, gap.best = "firstSEmax", 
    kmax = "", ...) 
{
    dimat <- as.matrix(bsd.object[[1]])
    if (kmax == "") {
        kmax <- nrow(dimat) - 1
    }
    if (find.best == T) {
        clusdat <- clusGap(dimat, B = B, FUNcluster = FUN, K.max = kmax)
        npart <- maxSE(f = clusdat$Tab[, 3], SE.f = clusdat$Tab[, 
            4], method = gap.best)
    }
    parts.list <- list()
    for (i in 1:kmax) {
        clus.temp <- FUN(dimat, k = i, ...)
        parts.list[[i]] <- clus.temp$clustering
    }
    parts.mat <- do.call("cbind", parts.list)
    rownames(parts.mat) <- rownames(dimat)
    colnames(parts.mat) <- paste0("k=", 1:ncol(parts.mat))
    res <- list(parts.mat, range(bsd.object[[1]]))
    names(res) <- c("parts.mat", "range.bsd")
    if (exists("npart")) {
        colnames(res[[1]])[npart] <- paste0(colnames(parts.mat)[npart], 
            "BEST")
        res[[3]] <- npart
        names(res)[3] <- "best.k"
    }
    if (find.best == T) {
        res[[4]] <- clusdat
        names(res)[4] <- "clusterdata"
    }
    class(res) <- "partitions"
    return(res)
}
> 
> 
> 
> cleanEx()
> nameEx("plot.partitions")
> ### * plot.partitions
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: plot.partitions
> ### Title: plot objects of class partitions
> ### Aliases: plot.partitions
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> 
> # Create a list of trees of class multiPhylo with four patterns of among-lineage rate variation 
> tr.fix <- rtree(10)
> 
> set.seed(12345)
> rates1 <- abs(rnorm(18, sd = 0.1))
> set.seed(123456)
> rates2 <- abs(rnorm(18, sd = 0.1))
> set.seed(1234567)
> rates3 <- abs(rnorm(18, sd = 0.1))
> set.seed(12345678)
> rates4 <- abs(rnorm(18, sd = 0.1))
> 
> trees.list <- list()
> 
> for(i in 1:20){
+       trees.list[[i]] <- tr.fix
+       if(i <= 5){
+       	   trees.list[[i]]$edge.length <- abs(rates1 + rnorm(18, 0, 0.01)) 
+       }else if(i > 5 && i <= 10){
+       	    trees.list[[i]]$edge.length <- abs(rates2 + rnorm(18, 0, 0.01)) 
+       }else if(i >= 10 && i < 15){
+       	    trees.list[[i]]$edge.length <- abs(rates3 + rnorm(18, 0, 0.01))  
+       }else{
+ 	    trees.list[[i]]$edge.length <- abs(rates4 + rnorm(18, 0, 0.01)) 
+       }
+ }
> 
> names(trees.list) <- paste0("tree", 1:20)
> class(trees.list) <- "multiPhylo"
> 
> # Estimate sBSDmin distance for all pairs of trees:
> trees.bsd <- bsd.matrix(trees.list)
[1] "Estimating tree distances"
[1] "estimating distances 1 of 19"
[1] "estimating distances 2 of 19"
[1] "estimating distances 3 of 19"
[1] "estimating distances 4 of 19"
[1] "estimating distances 5 of 19"
[1] "estimating distances 6 of 19"
[1] "estimating distances 7 of 19"
[1] "estimating distances 8 of 19"
[1] "estimating distances 9 of 19"
[1] "estimating distances 10 of 19"
[1] "estimating distances 11 of 19"
[1] "estimating distances 12 of 19"
[1] "estimating distances 13 of 19"
[1] "estimating distances 14 of 19"
[1] "estimating distances 15 of 19"
[1] "estimating distances 16 of 19"
[1] "estimating distances 17 of 19"
[1] "estimating distances 18 of 19"
[1] "estimating distances 19 of 19"
> 
> # Find the optimal number of partitions:
> partitions.object <- partitions(trees.bsd)
> 
> # plot partitions in two graphics devices
> plot(partitions.object)
dev.new(): using pdf(file="Rplots2.pdf")
> 
> 
> 
> 
> 
> 
> ## The function is currently defined as
> function (partitions.object, save.plot = F, file.name = "results_clockstar") 
+ {
+     image(t(partitions.object$parts.mat), col = sample(rainbow(ncol(partitions.object$parts.mat))), 
+         axes = F, ylab = "Data subset", main = "Partitioning scheeme for values of k")
+     mtext(text = rownames(partitions.object$parts.mat), side = 2, 
+         line = 0.3, at = seq(0, 1, 1/(nrow(partitions.object$parts.mat) - 
+             1)), las = 1, cex = 0.6)
+     mtext(text = colnames(partitions.object$parts.mat), side = 3, 
+         line = 0.3, at = seq(0, 1, 1/(ncol(partitions.object$parts.mat) - 
+             1)), las = 1, cex = 0.6)
+     if (save.plot) {
+         dev.copy2pdf(file = paste0(file.name, "_matrix.pdf"))
+     }
+     dev.new()
+     plot(partitions.object$clusterdata)
+     if (save.plot) {
+         dev.copy2pdf(file = paste0(file.name, "_gapstats.pdf"))
+         sapply(dev.list(), function(x) dev.off(x))
+     }
+   }
function (partitions.object, save.plot = F, file.name = "results_clockstar") 
{
    image(t(partitions.object$parts.mat), col = sample(rainbow(ncol(partitions.object$parts.mat))), 
        axes = F, ylab = "Data subset", main = "Partitioning scheeme for values of k")
    mtext(text = rownames(partitions.object$parts.mat), side = 2, 
        line = 0.3, at = seq(0, 1, 1/(nrow(partitions.object$parts.mat) - 
            1)), las = 1, cex = 0.6)
    mtext(text = colnames(partitions.object$parts.mat), side = 3, 
        line = 0.3, at = seq(0, 1, 1/(ncol(partitions.object$parts.mat) - 
            1)), las = 1, cex = 0.6)
    if (save.plot) {
        dev.copy2pdf(file = paste0(file.name, "_matrix.pdf"))
    }
    dev.new()
    plot(partitions.object$clusterdata)
    if (save.plot) {
        dev.copy2pdf(file = paste0(file.name, "_gapstats.pdf"))
        sapply(dev.list(), function(x) dev.off(x))
    }
}
> 
> 
> 
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  49.66 0.074 49.737 0 0 
> grDevices::dev.off()
pdf 
  2 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
