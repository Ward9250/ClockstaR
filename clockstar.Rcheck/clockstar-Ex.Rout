
R version 3.0.1 (2013-05-16) -- "Good Sport"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin10.8.0 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "clockstar"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('clockstar')
Loading required package: ape
Loading required package: phangorn
Loading required package: rgl
Warning in rgl.init(initValue) : RGL: unable to open X11 display
Warning in fun(libname, pkgname) : error in rgl_init
Loading required package: igraph

Attaching package: 'igraph'

The following object is masked from 'package:ape':

    as.igraph, edges

Loading required package: Matrix
Loading required package: lattice
Warning: replacing previous import 'as.igraph' when loading 'igraph'
Warning: replacing previous import 'edges' when loading 'igraph'
Loading required package: geiger
Loading required package: MASS
Loading required package: mvtnorm
Loading required package: msm
Loading required package: subplex
Loading required package: deSolve
Loading required package: colorspace
Loading required package: digest
Loading required package: Rcpp
Loading required package: coda
Loading required package: ncbit

Attaching package: 'geiger'

The following object is masked from 'package:ape':

    drop.tip, vcv.phylo

The following object is masked from 'package:base':

    load, transform

Loading required package: tcltk
Warning in fun(libname, pkgname) :
  no display name and no $DISPLAY environment variable
Loading required package: foreach
Loading required package: doParallel
Loading required package: iterators
Loading required package: parallel
Loading required package: cluster
Loading required package: Hmisc
Loading required package: survival
Loading required package: splines
Loading required package: Formula
Hmisc library by Frank E Harrell Jr

Type library(help='Hmisc'), ?Overview, or ?Hmisc.Overview')
to see overall documentation.


Attaching package: 'Hmisc'

The following object is masked from 'package:survival':

    untangle.specials

The following object is masked from 'package:ape':

    zoom

The following object is masked from 'package:base':

    format.pval, round.POSIXt, trunc.POSIXt, units

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("clockstar-package")
> ### * clockstar-package
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: clockstar-package
> ### Title: ClockstaR: Selecting partitioning strategies for relaxed
> ###   phylogenetic analysis
> ### Aliases: clockstar-package clockstar
> ### Keywords: Relaxed molecular clock
> 
> ### ** Examples
> 
> # This is an example of using ClockstaR in automatic mode.
> 
> # generate a list of trees with three patterns of among-lineage rate variation
> 
> fixed.topology <- rtree(10)
> fixed.topology$edge.length <- NULL
> tree.list <- list()
> set.seed(1234)
> patterns1 <- abs(rnorm(18, 0, 10))
> set.seed(3456)
> patterns2 <- abs(rnorm(18, 0, 10))
> set.seed(0987)
> patterns3 <- abs(rnorm(18, 0, 10))
> for(i in 1:3){
+ 	tree.list[[i]] <- fixed.topology
+ 	tree.list[[i]]$edge.length <- abs(patterns1 + rnorm(18))
+ }
> 
> for(i in 4:7){
+ 	tree.list[[i]] <- fixed.topology
+ 	tree.list[[i]]$edge.length <- abs(patterns2 + rnorm(18))
+ }
> 
> for(i in 8:10){
+ 	tree.list[[i]] <- fixed.topology
+ 	tree.list[[i]]$edge.length <- abs(patterns3 + rnorm(18))
+ }
> 
> # to inspect some of the trees:
> par(mfrow = c(3, 1))
> plot(tree.list[[1]])
> plot(tree.list[[4]])
> plot(tree.list[[10]])
> 
> # estimate sBSDmin for all pairs of trees
> 
> sbsdmin <- as.matrix(min.dist.topo.mat(tree.list)[[1]])
[1] "Estimating tree distances"
[1] "estimating distances 1 of 9"
[1] "estimating distances 2 of 9"
[1] "estimating distances 3 of 9"
[1] "estimating distances 4 of 9"
[1] "estimating distances 5 of 9"
[1] "estimating distances 6 of 9"
[1] "estimating distances 7 of 9"
[1] "estimating distances 8 of 9"
[1] "estimating distances 9 of 9"
> 
> groups.example <- get.all.groups(sbsdmin)
[1] "FINDING THE BEST NUMBER OF PARTITIONS (k) WITH GAP STATISTIC AND THE PAM ALGORITHM"
[1] 9
> 
> #print the partitions
> 
> print(groups.example)
$`Partition_ 1`
[1] "1" "2" "3"

$`Partition_ 2`
[1] "4" "5" "6" "7"

$`Partition_ 3`
[1] "8"  "9"  "10"

> 	
> 	
> 
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("convert.to.fasta")
> ### * convert.to.fasta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: convert.to.fasta
> ### Title: This function is used to convert nexus files to fasta format for
> ###   clockstar execution
> ### Aliases: convert.to.fasta
> ### Keywords: fasta format nexus format
> 
> ### ** Examples
> 
> ## Not run: 
> ##D data(woodmouse)
> ##D system("mkdir clockstar_function_example")
> ##D write.nexus.data(as.list(woodmouse), file = "./clockstar_function_example/woodmouse.nex")
> ##D convert.to.fasta("./clockstar_function_example")
> ## End(Not run)
> ## The function is currently defined as
> function(directory){
+ 	d <- getwd()
+ 	setwd(directory)
+ 	files <- grep(".nex", dir( ), value=T)
+ 	for(i in 1:length(files)){
+ 	file.temp <- read.nexus.data(files[i])
+ 	write.dna(as.DNAbin(file.temp),file=paste(substr(files[i], 1,nchar(files[i])-4), ".fasta", sep=""),  format="fasta", nbcol=-1, colsep="")
+ 	system(paste("rm", files[i]))
+ 	}
+ 	setwd(d)
+ }
function (directory) 
{
    d <- getwd()
    setwd(directory)
    files <- grep(".nex", dir(), value = T)
    for (i in 1:length(files)) {
        file.temp <- read.nexus.data(files[i])
        write.dna(as.DNAbin(file.temp), file = paste(substr(files[i], 
            1, nchar(files[i]) - 4), ".fasta", sep = ""), format = "fasta", 
            nbcol = -1, colsep = "")
        system(paste("rm", files[i]))
    }
    setwd(d)
}
> 
> 
> 
> cleanEx()
> nameEx("cut.trees.beta")
> ### * cut.trees.beta
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cut.trees.beta
> ### Title: cut.trees.beta calculated the diameter of a dendrogram. If the
> ###   diameter of the dendrogram is higher than that specified by the user,
> ###   the dendrogram is cut at its longest edge.
> ### Aliases: cut.trees.beta
> ### Keywords: sBSDmin diameter of a graph
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # generate an example dendrogram
> ##D set.seed(1234)
> ##D bsd.example <- unroot(rtree(10))
> ##D 
> ##D par(mfrow = c(1, 3))
> ##D plot(bsd.example, "unrooted")
> ##D subdendrograms <- cut.trees.beta(bsd.example, beta = 0.5)
> ##D plot(subdendrograms[[1]], "unrooted")
> ##D plot(subdendrograms[[2]], "unrooted")
> ## End(Not run)
> 
> 
> ## The function is currently defined as
> function (tree, beta = 0.05) 
+ {
+     if (length(tree$tip.label) >= 3) {
+         tree <- unroot(tree)
+     }
+     tree.diam <- max(cophenetic(tree))
+     pruned.trees <- list()
+     if (tree.diam > beta & (length(tree$tip.label) > 2)) {
+         di.nodes <- dist.nodes(tree)
+         max.edge <- max(tree$edge.length)
+         tips <- 1:length(tree$tip.label)
+         nodes <- 1:nrow(di.nodes)
+         nodes <- nodes[-tips]
+         connect.longest.edge <- which(di.nodes == max.edge, arr.ind = T)[1, 
+             ]
+         if ((connect.longest.edge[1] %in% nodes) & (connect.longest.edge[2] %in% 
+             nodes)) {
+             taxa.cut1 <- tips(tree, connect.longest.edge[1])
+             taxa.cut2 <- tips(tree, connect.longest.edge[2])
+             len.tax <- c(length(taxa.cut1), length(taxa.cut2))
+             node.cut <- connect.longest.edge[len.tax == min(len.tax)]
+             taxa.cut <- tips(tree, node.cut)
+         }
+         else if (sum(connect.longest.edge %in% nodes) == 1) {
+             node.cut <- connect.longest.edge[connect.longest.edge %in% 
+                 nodes]
+             taxa.cut <- tree$tip.label[connect.longest.edge[connect.longest.edge %in% 
+                 tips]]
+         }
+         taxa.prune <- taxa.cut
+         if ((length(tree$tip.label) - length(taxa.prune)) >= 
+             2) {
+             subtree1 <- drop.tip(tree, taxa.prune)
+             if (length(subtree1$tip.label) >= 3) {
+                 subtree1 <- unroot(subtree1)
+             }
+         }
+         else {
+             subtree1 <- tree$tip.label[!(tree$tip.label %in% 
+                 taxa.prune)]
+         }
+         if (length(taxa.prune) >= 2) {
+             subtree2 <- drop.tip(tree, tree$tip.label[!(tree$tip.label %in% 
+                 taxa.prune)])
+             if (length(subtree2$tip.label) >= 3) {
+                 subtree2 <- unroot(subtree2)
+             }
+         }
+         else {
+             subtree2 <- taxa.prune
+         }
+         pruned.trees[[1]] <- subtree1
+         pruned.trees[[2]] <- subtree2
+     }
+     else if (tree.diam < beta) {
+         pruned.trees[[1]] <- tree
+     }
+     else {
+         pruned.trees[[1]] <- tree$tip.label[1]
+         pruned.trees[[2]] <- tree$tip.label[2]
+     }
+     return(pruned.trees)
+   }
function (tree, beta = 0.05) 
{
    if (length(tree$tip.label) >= 3) {
        tree <- unroot(tree)
    }
    tree.diam <- max(cophenetic(tree))
    pruned.trees <- list()
    if (tree.diam > beta & (length(tree$tip.label) > 2)) {
        di.nodes <- dist.nodes(tree)
        max.edge <- max(tree$edge.length)
        tips <- 1:length(tree$tip.label)
        nodes <- 1:nrow(di.nodes)
        nodes <- nodes[-tips]
        connect.longest.edge <- which(di.nodes == max.edge, arr.ind = T)[1, 
            ]
        if ((connect.longest.edge[1] %in% nodes) & (connect.longest.edge[2] %in% 
            nodes)) {
            taxa.cut1 <- tips(tree, connect.longest.edge[1])
            taxa.cut2 <- tips(tree, connect.longest.edge[2])
            len.tax <- c(length(taxa.cut1), length(taxa.cut2))
            node.cut <- connect.longest.edge[len.tax == min(len.tax)]
            taxa.cut <- tips(tree, node.cut)
        }
        else if (sum(connect.longest.edge %in% nodes) == 1) {
            node.cut <- connect.longest.edge[connect.longest.edge %in% 
                nodes]
            taxa.cut <- tree$tip.label[connect.longest.edge[connect.longest.edge %in% 
                tips]]
        }
        taxa.prune <- taxa.cut
        if ((length(tree$tip.label) - length(taxa.prune)) >= 
            2) {
            subtree1 <- drop.tip(tree, taxa.prune)
            if (length(subtree1$tip.label) >= 3) {
                subtree1 <- unroot(subtree1)
            }
        }
        else {
            subtree1 <- tree$tip.label[!(tree$tip.label %in% 
                taxa.prune)]
        }
        if (length(taxa.prune) >= 2) {
            subtree2 <- drop.tip(tree, tree$tip.label[!(tree$tip.label %in% 
                taxa.prune)])
            if (length(subtree2$tip.label) >= 3) {
                subtree2 <- unroot(subtree2)
            }
        }
        else {
            subtree2 <- taxa.prune
        }
        pruned.trees[[1]] <- subtree1
        pruned.trees[[2]] <- subtree2
    }
    else if (tree.diam < beta) {
        pruned.trees[[1]] <- tree
    }
    else {
        pruned.trees[[1]] <- tree$tip.label[1]
        pruned.trees[[2]] <- tree$tip.label[2]
    }
    return(pruned.trees)
}
> 
> 
> 
> cleanEx()
> nameEx("diagnostics.clockstar")
> ### * diagnostics.clockstar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: diagnostics.clockstar
> ### Title: diagnostics.clockstar
> ### Aliases: diagnostics.clockstar
> ### Keywords: sBSDmin diameter of a graph
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Simulate 10 data sets with three different clocks
> ##D fixed.topology <- rtree(10)
> ##D fixed.topology$edge.length <- NULL
> ##D tree.list <- list()
> ##D set.seed(1234)
> ##D patterns1 <- abs(rnorm(18, 0, 10))
> ##D set.seed(3456)
> ##D patterns2 <- abs(rnorm(18, 0, 10))
> ##D set.seed(0987)
> ##D patterns3 <- abs(rnorm(18, 0, 10))
> ##D for(i in 1:3){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns1 + rnorm(18))
> ##D }
> ##D 
> ##D for(i in 4:7){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns2 + rnorm(18))
> ##D }
> ##D 
> ##D for(i in 8:10){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns3 + rnorm(18))
> ##D }
> ##D 
> ##D bsd.matrix.list <- as.matrix(min.dist.topo.mat(tree.list)[[1]])
> ##D 
> ##D example.partitions <- get.all.groups(bsd.matrix.list, pam.results = TRUE)
> ##D 
> ##D example.diagnostics <- diagnostics.clockstar(example.partitions)
> ## End(Not run)
> ## The function is currently defined as
> function(groups.obj, save.plots = FALSE, plots.file = "clockstar.diagnostics.pdf", interactive = TRUE)
+ {
+     if(length(groups.obj) == 3){
+         stop("The object specified is not the correct format. Please provide an the output of function get.all.groups. Please use pam.restuls = T")
+     }
+     gap.stat <- groups.obj[[2]][[1]][, 3]
+     ks <- 1:length(gap.stat)
+     errs.up <- gap.stat + groups.obj[[2]][[1]][, 4]
+     errs.down <- gap.stat - groups.obj[[2]][[1]][, 4]
+     k.matrix <- matrix(NA, nrow = nrow(groups.obj[[4]]), ncol = 1)
+     for(i in 1:length(ks)){
+         part <- pam(groups.obj[[4]], k = ks[i])
+         k.matrix <- cbind(k.matrix, as.matrix(part[[3]]))
+     }
+     k.matrix <- k.matrix[, 2:ncol(k.matrix)]
+     plot.matrices <- function(clust.matrix){
+         par(mar = c(2, 4, 2, 4))
+         image(t(as.matrix(clust.matrix)), axes = F, col = sample(rainbow(ncol(clust.matrix)*100), ncol(clust.matrix)), ylab = "Data subset")
+         mtext(text = rownames(clust.matrix), side = 2, line = 0.3, at = seq(0, 1, 1/(nrow(clust.matrix) - 1)), las = 1, cex = 0.6)
+         mtext(text = paste0("k=", ks), side = 3, line = 0.3, at = seq(0, 1, 1/(ncol(clust.matrix) - 1)), las = 1, cex = 0.6)
+     }
+     if(interactive == TRUE){
+     	par(mfrow = c(2, 1))
+     	par(mar = c(4, 4, 4, 4))
+     	errbar(x = ks, y = gap.stat, yplus = errs.up, yminus = errs.down, type = "b", pch = 20, xlab = expression(italic(k)), ylab = "Gap statistic")
+     	points(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", pch = 20)
+     	lines(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", pch = 20)
+     	lines(1:(length(groups.obj[[3]]) + 1), y = rep(0, length(groups.obj[[3]]) + 1), col = "blue")
+     	legend(x = max(ks)*0.7, y = min(gap.stat)*0.5, legend = c("Gap statistic and SE" ,"Delta Gap statistic", "Gap statistic = 0"), cex = 0.8, fill = c("black", "red", "blue"), bty = "n")
+     	plot.matrices(k.matrix)
+     }
+     if(save.plots == TRUE){
+         pdf(file = plots.file)
+     	par(mfrow = c(2, 1))
+         par(mar = c(4, 4, 4, 4))
+         errbar(x = ks, y = gap.stat, yplus = errs.up, yminus = errs.down, type = "b", pch = 20, xlab = expression(italic(k)), ylab = "Gap statistic")
+         points(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", pch = 20)
+         lines(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", pch = 20)
+         lines(1:(length(groups.obj[[3]]) + 1), y = rep(0, length(groups.obj[[3]]) + 1), , col = "blue")
+         legend(x = max(ks)*0.7, y = min(gap.stat)*0.5, legend = c("Gap statistic and SE" ,"Delta Gap statistic", "Gap statistic = 0"), cex = 0.8, fill = c("black", "red", "blue"), bty = "n")
+         plot.matrices(k.matrix)
+         dev.off()
+     }
+     return(k.matrix)
+ }
function (groups.obj, save.plots = FALSE, plots.file = "clockstar.diagnostics.pdf", 
    interactive = TRUE) 
{
    if (length(groups.obj) == 3) {
        stop("The object specified is not the correct format. Please provide an the output of function get.all.groups. Please use pam.restuls = T")
    }
    gap.stat <- groups.obj[[2]][[1]][, 3]
    ks <- 1:length(gap.stat)
    errs.up <- gap.stat + groups.obj[[2]][[1]][, 4]
    errs.down <- gap.stat - groups.obj[[2]][[1]][, 4]
    k.matrix <- matrix(NA, nrow = nrow(groups.obj[[4]]), ncol = 1)
    for (i in 1:length(ks)) {
        part <- pam(groups.obj[[4]], k = ks[i])
        k.matrix <- cbind(k.matrix, as.matrix(part[[3]]))
    }
    k.matrix <- k.matrix[, 2:ncol(k.matrix)]
    plot.matrices <- function(clust.matrix) {
        par(mar = c(2, 4, 2, 4))
        image(t(as.matrix(clust.matrix)), axes = F, col = sample(rainbow(ncol(clust.matrix) * 
            100), ncol(clust.matrix)), ylab = "Data subset")
        mtext(text = rownames(clust.matrix), side = 2, line = 0.3, 
            at = seq(0, 1, 1/(nrow(clust.matrix) - 1)), las = 1, 
            cex = 0.6)
        mtext(text = paste0("k=", ks), side = 3, line = 0.3, 
            at = seq(0, 1, 1/(ncol(clust.matrix) - 1)), las = 1, 
            cex = 0.6)
    }
    if (interactive == TRUE) {
        par(mfrow = c(2, 1))
        par(mar = c(4, 4, 4, 4))
        errbar(x = ks, y = gap.stat, yplus = errs.up, yminus = errs.down, 
            type = "b", pch = 20, xlab = expression(italic(k)), 
            ylab = "Gap statistic")
        points(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", 
            pch = 20)
        lines(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", 
            pch = 20)
        lines(1:(length(groups.obj[[3]]) + 1), y = rep(0, length(groups.obj[[3]]) + 
            1), col = "blue")
        legend(x = max(ks) * 0.7, y = min(gap.stat) * 0.5, legend = c("Gap statistic and SE", 
            "Delta Gap statistic", "Gap statistic = 0"), cex = 0.8, 
            fill = c("black", "red", "blue"), bty = "n")
        plot.matrices(k.matrix)
    }
    if (save.plots == TRUE) {
        pdf(file = plots.file)
        par(mfrow = c(2, 1))
        par(mar = c(4, 4, 4, 4))
        errbar(x = ks, y = gap.stat, yplus = errs.up, yminus = errs.down, 
            type = "b", pch = 20, xlab = expression(italic(k)), 
            ylab = "Gap statistic")
        points(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", 
            pch = 20)
        lines(1:length(groups.obj[[3]]), groups.obj[[3]], col = "red", 
            pch = 20)
        lines(1:(length(groups.obj[[3]]) + 1), y = rep(0, length(groups.obj[[3]]) + 
            1), , col = "blue")
        legend(x = max(ks) * 0.7, y = min(gap.stat) * 0.5, legend = c("Gap statistic and SE", 
            "Delta Gap statistic", "Gap statistic = 0"), cex = 0.8, 
            fill = c("black", "red", "blue"), bty = "n")
        plot.matrices(k.matrix)
        dev.off()
    }
    return(k.matrix)
}
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("get.all.groups")
> ### * get.all.groups
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get.all.groups
> ### Title: This function finds the best number of partitions (k) for a data
> ###   set, and the data subsets in each partitions, as described in Duchene
> ###   et al.
> ### Aliases: get.all.groups
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> # This is the same example in the package description
> # generate a list of trees with three patterns of among-lineage rate variation
> ## Not run: 
> ##D 
> ##D fixed.topology <- rtree(10)
> ##D fixed.topology$edge.length <- NULL
> ##D tree.list <- list()
> ##D set.seed(1234)
> ##D patterns1 <- abs(rnorm(18, 0, 10))
> ##D set.seed(3456)
> ##D patterns2 <- abs(rnorm(18, 0, 10))
> ##D set.seed(0987)
> ##D patterns3 <- abs(rnorm(18, 0, 10))
> ##D for(i in 1:3){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns1 + rnorm(18))
> ##D }
> ##D 
> ##D for(i in 4:7){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns2 + rnorm(18))
> ##D }
> ##D 
> ##D for(i in 8:10){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns3 + rnorm(18))
> ##D }
> ##D 
> ##D # to inspect some of the trees:
> ##D par(mfrow = c(3, 1))
> ##D plot(tree.list[[1]])
> ##D plot(tree.list[[4]])
> ##D plot(tree.list[[10]])
> ##D 
> ##D # estimate sBSDmin for all pairs of trees
> ##D 
> ##D sbsdmin <- as.matrix(min.dist.topo.mat(tree.list)[[1]])
> ##D 
> ##D groups.example <- get.all.groups(sbsdmin)
> ##D 
> ##D #print the partitions
> ##D 
> ##D print(groups.example)
> ## End(Not run)	
> 
> 
> ## The function is currently defined as
> function (data.obj, n.b = 500, pam.results = F, save.partitions = F, 
+     file.name = "partitions.txt", beta = 0.03, ...) 
+ {
+     if (class(data.obj) %in% c("data.frame", "matrix")) {
+         kmax <- nrow(data.obj) - 1
+         print("FINDING THE BEST NUMBER OF PARTITIONS (k) WITH GAP STATISTIC AND THE PAM ALGORITHM")
+         print(kmax)
+         pam.gap <- clusGap(data.obj, pam, B = n.b, K.max = kmax)
+         rownames(pam.gap[[1]]) <- paste0("k=", 1:nrow(pam.gap[[1]]))
+         gaps <- pam.gap$Tab[, 3]
+         diffs <- vector()
+         for (i in 1:(length(gaps) - 1)) {
+             diffs <- c(diffs, gaps[i] - gaps[i + 1])
+         }
+         names(diffs) <- paste0("k=", 1:length(diffs))
+         all.k <- (1:length(diffs))[diffs > 0]
+         best.k <- maxSE(pam.gap[[1]][, 3], pam.gap[[1]][, 4])
+         pam.k <- pam(data.obj, k = best.k, ...)
+         partitions <- unique(pam.k$clustering)
+         res.data <- list()
+         for (i in 1:length(partitions)) {
+             res.data[[i]] <- names(which(pam.k$clustering == 
+                 partitions[i]))
+         }
+         names(res.data) <- paste("Partition_", 1:length(res.data))
+         if (save.partitions == T) {
+             cat("Partitions selected with automatic mode \n", 
+                 file = file.name)
+             for (m in 1:length(res.data)) {
+                 cat(names(res.data[m]), file = file.name, sep = "\n", 
+                   append = T)
+                 cat(res.data[[m]], file = file.name, append = T)
+                 cat("\n", file = file.name, append = T)
+             }
+         }
+         if (pam.results == T) {
+             lis.res <- list(res.data, pam.gap, diffs, data.obj)
+             return(lis.res)
+         }
+         else if (pam.results == F) {
+             return(res.data)
+         }
+     }
+     else if (class(data.obj) == "phylo") {
+         tree <- data.obj
+         temp.list <- list()
+         min.list <- list()
+         temp.list[[1]] <- tree
+         get.diameter <- function(tr) {
+             if (class(tr) == "phylo") {
+                 return(max(cophenetic(tr)))
+             }
+             else {
+                 return(0)
+             }
+         }
+         diams <- sapply(temp.list, get.diameter)
+         if (any(diams > beta)) {
+             while (length(temp.list) != 0) {
+                 diams <- sapply(temp.list, get.diameter)
+                 if (sum(diams <= beta) > 0) {
+                   diams.beta <- seq(from = 1, to = length(diams))[diams <= 
+                     beta]
+                   for (i in diams.beta) {
+                     min.list[[length(min.list) + 1]] <- temp.list[[i]]
+                   }
+                 }
+                 else {
+                   diams.beta = 0
+                 }
+                 if (sum(diams > beta) > 0) {
+                   diams.non.beta <- seq(from = 1, to = length(diams))[diams > 
+                     beta]
+                   temp.list.non.beta <- list()
+                   for (j in 1:length(diams.non.beta)) {
+                     temp.list.non.beta[[j]] <- temp.list[[diams.non.beta[j]]]
+                   }
+                   temp.list <- temp.list.non.beta
+                   sub.list <- list()
+                   for (k in 1:length(temp.list)) {
+                     cut.temp <- cut.trees.beta(temp.list[[k]], 
+                       beta)
+                     sub.list[[length(sub.list) + 1]] <- cut.temp[[1]]
+                     if (length(cut.temp) == 2) {
+                       sub.list[[length(sub.list) + 1]] <- cut.temp[[2]]
+                     }
+                   }
+                   temp.list = sub.list[1:length(sub.list)]
+                 }
+                 else {
+                   temp.list <- list()
+                 }
+             }
+         }
+         else {
+             min.list <- temp.list
+         }
+         for (l in 1:length(min.list)) {
+             if (class(min.list[[l]]) == "phylo") {
+                 tips <- min.list[[l]]$tip.label
+                 min.list[[l]] <- tips
+             }
+         }
+         names(min.list) <- paste("Partition_", 1:length(min.list))
+         if (save.partitions == T) {
+             cat(paste("partitions with selected beta =", beta, 
+                 "\n"), file = file.name)
+             for (m in 1:length(min.list)) {
+                 cat(names(min.list[m]), file = file.name, sep = "\n", 
+                   append = T)
+                 cat(min.list[[m]], file = file.name, append = T)
+                 cat("\n", file = file.name, append = T)
+             }
+         }
+         return(min.list)
+     }
+     else {
+         stop("Please supply the distance between trees. This should be an object of classs Matrix of data.frame. For objects of class dist, use as.matrix(data) to change the class of the object")
+     }
+   }
function (data.obj, n.b = 500, pam.results = F, save.partitions = F, 
    file.name = "partitions.txt", beta = 0.03, ...) 
{
    if (class(data.obj) %in% c("data.frame", "matrix")) {
        kmax <- nrow(data.obj) - 1
        print("FINDING THE BEST NUMBER OF PARTITIONS (k) WITH GAP STATISTIC AND THE PAM ALGORITHM")
        print(kmax)
        pam.gap <- clusGap(data.obj, pam, B = n.b, K.max = kmax)
        rownames(pam.gap[[1]]) <- paste0("k=", 1:nrow(pam.gap[[1]]))
        gaps <- pam.gap$Tab[, 3]
        diffs <- vector()
        for (i in 1:(length(gaps) - 1)) {
            diffs <- c(diffs, gaps[i] - gaps[i + 1])
        }
        names(diffs) <- paste0("k=", 1:length(diffs))
        all.k <- (1:length(diffs))[diffs > 0]
        best.k <- maxSE(pam.gap[[1]][, 3], pam.gap[[1]][, 4])
        pam.k <- pam(data.obj, k = best.k, ...)
        partitions <- unique(pam.k$clustering)
        res.data <- list()
        for (i in 1:length(partitions)) {
            res.data[[i]] <- names(which(pam.k$clustering == 
                partitions[i]))
        }
        names(res.data) <- paste("Partition_", 1:length(res.data))
        if (save.partitions == T) {
            cat("Partitions selected with automatic mode \n", 
                file = file.name)
            for (m in 1:length(res.data)) {
                cat(names(res.data[m]), file = file.name, sep = "\n", 
                  append = T)
                cat(res.data[[m]], file = file.name, append = T)
                cat("\n", file = file.name, append = T)
            }
        }
        if (pam.results == T) {
            lis.res <- list(res.data, pam.gap, diffs, data.obj)
            return(lis.res)
        }
        else if (pam.results == F) {
            return(res.data)
        }
    }
    else if (class(data.obj) == "phylo") {
        tree <- data.obj
        temp.list <- list()
        min.list <- list()
        temp.list[[1]] <- tree
        get.diameter <- function(tr) {
            if (class(tr) == "phylo") {
                return(max(cophenetic(tr)))
            }
            else {
                return(0)
            }
        }
        diams <- sapply(temp.list, get.diameter)
        if (any(diams > beta)) {
            while (length(temp.list) != 0) {
                diams <- sapply(temp.list, get.diameter)
                if (sum(diams <= beta) > 0) {
                  diams.beta <- seq(from = 1, to = length(diams))[diams <= 
                    beta]
                  for (i in diams.beta) {
                    min.list[[length(min.list) + 1]] <- temp.list[[i]]
                  }
                }
                else {
                  diams.beta = 0
                }
                if (sum(diams > beta) > 0) {
                  diams.non.beta <- seq(from = 1, to = length(diams))[diams > 
                    beta]
                  temp.list.non.beta <- list()
                  for (j in 1:length(diams.non.beta)) {
                    temp.list.non.beta[[j]] <- temp.list[[diams.non.beta[j]]]
                  }
                  temp.list <- temp.list.non.beta
                  sub.list <- list()
                  for (k in 1:length(temp.list)) {
                    cut.temp <- cut.trees.beta(temp.list[[k]], 
                      beta)
                    sub.list[[length(sub.list) + 1]] <- cut.temp[[1]]
                    if (length(cut.temp) == 2) {
                      sub.list[[length(sub.list) + 1]] <- cut.temp[[2]]
                    }
                  }
                  temp.list = sub.list[1:length(sub.list)]
                }
                else {
                  temp.list <- list()
                }
            }
        }
        else {
            min.list <- temp.list
        }
        for (l in 1:length(min.list)) {
            if (class(min.list[[l]]) == "phylo") {
                tips <- min.list[[l]]$tip.label
                min.list[[l]] <- tips
            }
        }
        names(min.list) <- paste("Partition_", 1:length(min.list))
        if (save.partitions == T) {
            cat(paste("partitions with selected beta =", beta, 
                "\n"), file = file.name)
            for (m in 1:length(min.list)) {
                cat(names(min.list[m]), file = file.name, sep = "\n", 
                  append = T)
                cat(min.list[[m]], file = file.name, append = T)
                cat("\n", file = file.name, append = T)
            }
        }
        return(min.list)
    }
    else {
        stop("Please supply the distance between trees. This should be an object of classs Matrix of data.frame. For objects of class dist, use as.matrix(data) to change the class of the object")
    }
}
> 
> 
> 
> cleanEx()
> nameEx("get.all.groups.k")
> ### * get.all.groups.k
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: get.all.groups.k
> ### Title: This function finds the best partitioning strategy for a fixed
> ###   number of partitions, as described in Duchene et al.
> ### Aliases: get.all.groups.k
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> # This is the same example in the package description
> # generate a list of trees with three patterns of among-lineage rate variation
> ## Not run: 
> ##D fixed.topology <- rtree(10)
> ##D fixed.topology$edge.length <- NULL
> ##D tree.list <- list()
> ##D set.seed(1234)
> ##D patterns1 <- abs(rnorm(18, 0, 10))
> ##D set.seed(3456)
> ##D patterns2 <- abs(rnorm(18, 0, 10))
> ##D set.seed(0987)
> ##D patterns3 <- abs(rnorm(18, 0, 10))
> ##D for(i in 1:3){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns1 + rnorm(18))
> ##D }
> ##D 
> ##D for(i in 4:7){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns2 + rnorm(18))
> ##D }
> ##D 
> ##D for(i in 8:10){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns3 + rnorm(18))
> ##D }
> ##D 
> ##D # to inspect some of the trees:
> ##D par(mfrow = c(3, 1))
> ##D plot(tree.list[[1]])
> ##D plot(tree.list[[4]])
> ##D plot(tree.list[[10]])
> ##D 
> ##D # estimate sBSDmin for all pairs of trees
> ##D 
> ##D sbsdmin <- as.matrix(min.dist.topo.mat(tree.list)[[1]])
> ##D 
> ##D groups.example <- get.all.groups.k(sbsdmin, k.man = 3)
> ##D 
> ##D #print the partitions
> ##D 
> ##D print(groups.example)
> ##D 	
> ## End(Not run)
> ## The function is currently defined as
> function (data.obj, k.man = 1, save.partitions = F, file.name = "partitions.txt") 
+ {
+     if (class(data.obj) %in% c("data.frame", "matrix")) {
+         print("The data object is a data frame or a matrix. The partitions will be defined with the PAM algorithm")
+         if (k.man == 1) {
+             stop("The selected number of partitions is 1. Please select k.man for  >1")
+         }
+         else {
+             pam.k <- pam(data.obj, k = k.man)
+             partitions <- unique(pam.k$clustering)
+             res.data <- list()
+             for (i in 1:length(partitions)) {
+                 res.data[[i]] <- names(which(pam.k$clustering == 
+                   partitions[i]))
+             }
+             names(res.data) <- paste("Partition_", 1:length(res.data))
+             if (save.partitions == T) {
+                 cat(paste("Partitions selected with manual mode for k =", 
+                   k.man, "\n"), file = file.name)
+                 for (m in 1:length(res.data)) {
+                   cat(names(res.data[m]), file = file.name, sep = "\n", 
+                     append = T)
+                   cat(res.data[[m]], file = file.name, append = T)
+                   cat("\n", file = file.name, append = T)
+                 }
+             }
+             return(res.data)
+         }
+     }
+     else if (class(data.obj) == "phylo") {
+         print("The data object is a dendrogram (phylo object). The partitions will be defined but cutting the dendrobran along the longest edge")
+         tree <- data.obj
+         k = 2
+         tree.list <- list()
+         tree.list[[1]] <- tree
+         while (length(tree.list) < k) {
+             diams <- sapply(tree.list, function(tr) {
+                 if (class(tr) == "phylo") {
+                   return(max(cophenetic(tr)))
+                 }
+                 else {
+                   return(0)
+                 }
+             })
+             tree.to.cut <- tree.list[[which(diams == max(diams))]]
+             tree.list <- tree.list[-which(diams == max(diams))]
+             tree.list[c(length(tree.list) + 1, length(tree.list) + 
+                 2)] <- cut.trees.beta(tree.to.cut, beta = 0)
+         }
+         for (l in 1:length(tree.list)) {
+             if (class(tree.list[[l]]) == "phylo") {
+                 tips <- tree.list[[l]]$tip.label
+                 tree.list[[l]] <- tips
+             }
+         }
+         names(tree.list) <- paste("Partition_", 1:length(tree.list))
+         if (save.partitions == T) {
+             cat(paste("partitions with selected k =", k, "\n"), 
+                 file = file.name)
+             for (m in 1:length(tree.list)) {
+                 cat(names(tree.list[m]), file = file.name, sep = "\n", 
+                   append = T)
+                 cat(tree.list[[m]], file = file.name, append = T)
+                 cat("\n", file = file.name, append = T)
+             }
+         }
+         return(tree.list)
+     }
+   }
function (data.obj, k.man = 1, save.partitions = F, file.name = "partitions.txt") 
{
    if (class(data.obj) %in% c("data.frame", "matrix")) {
        print("The data object is a data frame or a matrix. The partitions will be defined with the PAM algorithm")
        if (k.man == 1) {
            stop("The selected number of partitions is 1. Please select k.man for  >1")
        }
        else {
            pam.k <- pam(data.obj, k = k.man)
            partitions <- unique(pam.k$clustering)
            res.data <- list()
            for (i in 1:length(partitions)) {
                res.data[[i]] <- names(which(pam.k$clustering == 
                  partitions[i]))
            }
            names(res.data) <- paste("Partition_", 1:length(res.data))
            if (save.partitions == T) {
                cat(paste("Partitions selected with manual mode for k =", 
                  k.man, "\n"), file = file.name)
                for (m in 1:length(res.data)) {
                  cat(names(res.data[m]), file = file.name, sep = "\n", 
                    append = T)
                  cat(res.data[[m]], file = file.name, append = T)
                  cat("\n", file = file.name, append = T)
                }
            }
            return(res.data)
        }
    }
    else if (class(data.obj) == "phylo") {
        print("The data object is a dendrogram (phylo object). The partitions will be defined but cutting the dendrobran along the longest edge")
        tree <- data.obj
        k = 2
        tree.list <- list()
        tree.list[[1]] <- tree
        while (length(tree.list) < k) {
            diams <- sapply(tree.list, function(tr) {
                if (class(tr) == "phylo") {
                  return(max(cophenetic(tr)))
                }
                else {
                  return(0)
                }
            })
            tree.to.cut <- tree.list[[which(diams == max(diams))]]
            tree.list <- tree.list[-which(diams == max(diams))]
            tree.list[c(length(tree.list) + 1, length(tree.list) + 
                2)] <- cut.trees.beta(tree.to.cut, beta = 0)
        }
        for (l in 1:length(tree.list)) {
            if (class(tree.list[[l]]) == "phylo") {
                tips <- tree.list[[l]]$tip.label
                tree.list[[l]] <- tips
            }
        }
        names(tree.list) <- paste("Partition_", 1:length(tree.list))
        if (save.partitions == T) {
            cat(paste("partitions with selected k =", k, "\n"), 
                file = file.name)
            for (m in 1:length(tree.list)) {
                cat(names(tree.list[m]), file = file.name, sep = "\n", 
                  append = T)
                cat(tree.list[[m]], file = file.name, append = T)
                cat("\n", file = file.name, append = T)
            }
        }
        return(tree.list)
    }
}
> 
> 
> 
> cleanEx()
> nameEx("min.dist.topo")
> ### * min.dist.topo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: min.dist.topo
> ### Title: This function estimates the sBSDmin value described in Duchene
> ###   et al.
> ### Aliases: min.dist.topo
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Simulate a tree and store it in two objects
> ##D tr1 <- rtree(50)
> ##D tr2 <- tr1
> ##D # change the branch lengths of one of the trees 
> ##D tr2$edge.length <- abs(rnorm(length(tr1$edge.length), 0.02, 2)) 
> ##D 
> ##D # plot the trees to verify that their specific are different 
> ##D par(mfrow = c(1, 2))
> ##D plot(tr1, show.tip.label = FALSE, direction = "right")
> ##D plot(tr2, show.tip.label = FALSE, direction = "left")
> ##D 
> ##D #Estimate the beta
> ##D min.dist.topo(tr1, tr2)
> ## End(Not run)
> 
> ## The function is currently defined as
> function (tree1, tree2) 
+ {
+     list.tr <- list()
+     list.tr[[1]] <- tree1
+     list.tr[[2]] <- tree2
+     lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
+     tree1 <- list.tr[lens == max(lens)][[1]]
+     tree2 <- list.tr[lens == min(lens)][[1]]
+     tree.dist.opt <- function(x) {
+         tree3 <- tree2
+         tree3$edge.length <- tree2$edge.length * x
+         return(dist.topo(tree1, tree3, method = "score"))
+     }
+     opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
+         lower = 0, upper = 50)
+     min.bdi <- opt.dist$value
+     scaling <- opt.dist$par
+     tree2.scaled <- tree2
+     tree2.scaled$edge.length <- tree2$edge.length * scaling
+     root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
+         1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
+         1e-05]))
+     tree1.root.scaled <- tree1
+     tree2.root.scaled <- tree2.scaled
+     tree1.root.scaled$edge.length <- tree1$edge.length * root.scaling
+     tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
+         root.scaling
+     min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
+         method = "score")
+     res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
+     names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
+         "min.bdi")
+     return(res.vect)
+   }
function (tree1, tree2) 
{
    list.tr <- list()
    list.tr[[1]] <- tree1
    list.tr[[2]] <- tree2
    lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
    tree1 <- list.tr[lens == max(lens)][[1]]
    tree2 <- list.tr[lens == min(lens)][[1]]
    tree.dist.opt <- function(x) {
        tree3 <- tree2
        tree3$edge.length <- tree2$edge.length * x
        return(dist.topo(tree1, tree3, method = "score"))
    }
    opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
        lower = 0, upper = 50)
    min.bdi <- opt.dist$value
    scaling <- opt.dist$par
    tree2.scaled <- tree2
    tree2.scaled$edge.length <- tree2$edge.length * scaling
    root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
        1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
        1e-05]))
    tree1.root.scaled <- tree1
    tree2.root.scaled <- tree2.scaled
    tree1.root.scaled$edge.length <- tree1$edge.length * root.scaling
    tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
        root.scaling
    min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
        method = "score")
    res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
    names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
        "min.bdi")
    return(res.vect)
}
> 
> 
> 
> cleanEx()
> nameEx("min.dist.topo.mat")
> ### * min.dist.topo.mat
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: min.dist.topo.mat
> ### Title: Estimate the pairwise BSDmin for a list of trees
> ### Aliases: min.dist.topo.mat
> ### Keywords: BSDmin distance tree distance score
> 
> ### ** Examples
> 
> ## Not run: 
> ##D trees <- list()
> ##D tr <- rtree(10)
> ##D for(i in 1:10){
> ##D 	trees[[i]] <- tr
> ##D 	trees[[i]]$edge.length <- abs(rnorm(length(tr$edge.length))) + 0.01 # simulate random branch lengths
> ##D }
> ##D 
> ##D bsd.matrix.list <- min.dist.topo.mat(trees)
> ##D 
> ##D par(mfrow = c(2, 1))
> ##D hist(bsd.matrix.list[[1]], main = "BSDmin distances in simulated branch lengths", ylab = "Frequency", xlab = expression(beta))
> ##D hist(bsd.matrix.list[[2]], main = "Scaling factors in simulated branch lengths", ylab = "Frequency", xlab = expression(beta))
> ## End(Not run)
> 
> ## The function is currently defined as
> function (tree.list) 
+ {
+     d.mat <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
+     rownames(d.mat) <- names(tree.list)
+     colnames(d.mat) <- names(tree.list)
+     s.mat <- d.mat
+     print("Estimating tree distances")
+     if (length(tree.list) > 3) {
+         d.mat.lin <- vector()
+         d.mat.lin <- sapply(2:nrow(d.mat), function(a) {
+             print(paste("estimating distances", a - 1, "of", 
+                 nrow(d.mat) - 1))
+             lapply(tree.list[1:(a - 1)], function(y) {
+                 min.dist.topo(tree1 = y, tree2 = tree.list[[a]])
+             })
+         })
+         for (a in 1:length(d.mat.lin)) {
+             vec.temp.dist <- vector()
+             vec.temp.scale <- vector()
+             for (b in 1:length(d.mat.lin[[a]])) {
+                 vec.temp.dist[b] <- d.mat.lin[[a]][[b]][1]
+                 vec.temp.scale[b] <- d.mat.lin[[a]][[b]][2]
+             }
+             d.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.dist
+             s.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.scale
+         }
+     }
+     else if (length(tree.list) <= 3) {
+         stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
+     }
+     d.mat.lin <- min.dist.topo(tree.list[[1]], tree.list[[2]])
+     d.mat[2, 1] <- d.mat.lin[1]
+     s.mat[2, 1] <- d.mat.lin[2]
+     res.list <- list()
+     res.list[[1]] <- as.dist(d.mat)
+     res.list[[2]] <- s.mat
+     return(res.list)
+   }
function (tree.list) 
{
    d.mat <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
    rownames(d.mat) <- names(tree.list)
    colnames(d.mat) <- names(tree.list)
    s.mat <- d.mat
    print("Estimating tree distances")
    if (length(tree.list) > 3) {
        d.mat.lin <- vector()
        d.mat.lin <- sapply(2:nrow(d.mat), function(a) {
            print(paste("estimating distances", a - 1, "of", 
                nrow(d.mat) - 1))
            lapply(tree.list[1:(a - 1)], function(y) {
                min.dist.topo(tree1 = y, tree2 = tree.list[[a]])
            })
        })
        for (a in 1:length(d.mat.lin)) {
            vec.temp.dist <- vector()
            vec.temp.scale <- vector()
            for (b in 1:length(d.mat.lin[[a]])) {
                vec.temp.dist[b] <- d.mat.lin[[a]][[b]][1]
                vec.temp.scale[b] <- d.mat.lin[[a]][[b]][2]
            }
            d.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.dist
            s.mat[a + 1, 1:length(vec.temp.dist)] <- vec.temp.scale
        }
    }
    else if (length(tree.list) <= 3) {
        stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
    }
    d.mat.lin <- min.dist.topo(tree.list[[1]], tree.list[[2]])
    d.mat[2, 1] <- d.mat.lin[1]
    s.mat[2, 1] <- d.mat.lin[2]
    res.list <- list()
    res.list[[1]] <- as.dist(d.mat)
    res.list[[2]] <- s.mat
    return(res.list)
}
> 
> 
> 
> cleanEx()
> nameEx("min.dist.topo.mat.para")
> ### * min.dist.topo.mat.para
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: min.dist.topo.mat.para
> ### Title: Estimate the pairwise BSDmin for a list of trees
> ### Aliases: min.dist.topo.mat.para
> ### Keywords: BSDmin distance tree distance score
> 
> ### ** Examples
> 
> ## Not run: 
> ##D tr <- rtree(10) # simulate a random tree
> ##D 
> ##D trees <- list()
> ##D for(i in 1:10){
> ##D 	trees[[i]] <- tr
> ##D 	trees[[i]]$edge.length <- abs(rnorm(length(tr$edge.length))) + 0.01 # simulate random branch lengths
> ##D }
> ##D 
> ##D bsd.matrix.list <- min.dist.topo.mat.para(trees, para = FALSE, ncore = 1)# set para = T and ncore = number of cores to run in parallel
> ##D 
> ##D par(mfrow = c(2, 1))
> ##D hist(bsd.matrix.list[[1]], main = "BSDmin distances in simulated branch lengths", ylab = "Frequency", xlab = expression(beta))
> ##D hist(bsd.matrix.list[[2]], main = "Scaling factors in simulated branch lengths", ylab = "Frequency", xlab = expression(beta))
> ##D 
> ##D 
> ## End(Not run)
> 
> 
> ## The function is currently defined as
> function (tree.list, para = F, ncore = 1) 
+ {
+     if (length(tree.list) <= 3) {
+         stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
+     }
+     min.dist.topo <- function(tree1, tree2) {
+         list.tr <- list()
+         list.tr[[1]] <- tree1
+         list.tr[[2]] <- tree2
+         lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
+         tree1 <- list.tr[lens == max(lens)][[1]]
+         tree2 <- list.tr[lens == min(lens)][[1]]
+         tree.dist.opt <- function(x) {
+             tree3 <- tree2
+             tree3$edge.length <- tree2$edge.length * x
+             return(dist.topo(tree1, tree3, method = "score"))
+         }
+         opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
+             lower = 0, upper = 50)
+         min.bdi <- opt.dist$value
+         scaling <- opt.dist$par
+         tree2.scaled <- tree2
+         tree2.scaled$edge.length <- tree2$edge.length * scaling
+         root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
+             1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
+             1e-05]))
+         tree1.root.scaled <- tree1
+         tree2.root.scaled <- tree2.scaled
+         tree1.root.scaled$edge.length <- tree1$edge.length * 
+             root.scaling
+         tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
+             root.scaling
+         min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
+             method = "score")
+         res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
+         names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
+             "min.bdi")
+         return(res.vect)
+     }
+     sub.trees <- list()
+     for (k in 2:length(tree.list)) {
+         sub.trees[[k]] <- tree.list[1:k - 1]
+     }
+     compute.tree.dists <- function(tree.sub.list, fix.tree) {
+         res <- sapply(tree.sub.list, function(a) {
+             return(min.dist.topo(fix.tree, a))
+         })
+         return(res)
+     }
+     if (para == T) {
+         cl <- makeCluster(ncore)
+         registerDoParallel(cl)
+         print(paste("Clusters registered as follows: ", cl))
+         res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
+             .packages = c("ape", "phangorn")) %dopar% compute.tree.dists(tree.sub.list = s.trees, 
+             fix.tree = tree.list[[j]])
+         stopCluster(cl)
+     }
+     else if (para == F) {
+         res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
+             .packages = c("ape", "phangorn")) %do% compute.tree.dists(tree.sub.list = s.trees, 
+             tree.list[[j]])
+     }
+     res.list <- list()
+     res.list[[1]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
+     for (m in 2:nrow(res.list[[1]])) {
+         res.list[[1]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][1, 
+             ]
+     }
+     rownames(res.list[[1]]) <- names(tree.list)
+     colnames(res.list[[1]]) <- names(tree.list)
+     res.list[[1]] <- as.dist(res.list[[1]])
+     res.list[[2]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
+     for (m in 2:nrow(res.list[[2]])) {
+         res.list[[2]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][2, 
+             ]
+     }
+     rownames(res.list[[2]]) <- names(tree.list)
+     colnames(res.list[[2]]) <- names(tree.list)
+     return(res.list)
+   }
function (tree.list, para = F, ncore = 1) 
{
    if (length(tree.list) <= 3) {
        stop("The number of gene trees is <= 3. ClockstaR requires at least gene 4 trees")
    }
    min.dist.topo <- function(tree1, tree2) {
        list.tr <- list()
        list.tr[[1]] <- tree1
        list.tr[[2]] <- tree2
        lens <- c(sum(tree1$edge.length), sum(tree2$edge.length))
        tree1 <- list.tr[lens == max(lens)][[1]]
        tree2 <- list.tr[lens == min(lens)][[1]]
        tree.dist.opt <- function(x) {
            tree3 <- tree2
            tree3$edge.length <- tree2$edge.length * x
            return(dist.topo(tree1, tree3, method = "score"))
        }
        opt.dist <- optim(0, fn = tree.dist.opt, method = "Brent", 
            lower = 0, upper = 50)
        min.bdi <- opt.dist$value
        scaling <- opt.dist$par
        tree2.scaled <- tree2
        tree2.scaled$edge.length <- tree2$edge.length * scaling
        root.scaling <- 0.05/mean(c(tree1$edge.length[tree1$edge.length > 
            1e-05], tree2.scaled$edge.length[tree2.scaled$edge.length > 
            1e-05]))
        tree1.root.scaled <- tree1
        tree2.root.scaled <- tree2.scaled
        tree1.root.scaled$edge.length <- tree1$edge.length * 
            root.scaling
        tree2.root.scaled$edge.length <- tree2.scaled$edge.length * 
            root.scaling
        min.bdi.root.scaled <- dist.topo(tree1.root.scaled, tree2.root.scaled, 
            method = "score")
        res.vect <- c(min.bdi.root.scaled, scaling, min.bdi)
        names(res.vect) <- c("min.bdi.scaled", "scaling.factor", 
            "min.bdi")
        return(res.vect)
    }
    sub.trees <- list()
    for (k in 2:length(tree.list)) {
        sub.trees[[k]] <- tree.list[1:k - 1]
    }
    compute.tree.dists <- function(tree.sub.list, fix.tree) {
        res <- sapply(tree.sub.list, function(a) {
            return(min.dist.topo(fix.tree, a))
        })
        return(res)
    }
    if (para == T) {
        cl <- makeCluster(ncore)
        registerDoParallel(cl)
        print(paste("Clusters registered as follows: ", cl))
        res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
            .packages = c("ape", "phangorn")) %dopar% compute.tree.dists(tree.sub.list = s.trees, 
            fix.tree = tree.list[[j]])
        stopCluster(cl)
    }
    else if (para == F) {
        res.par <- foreach(s.trees = sub.trees, j = 1:length(tree.list), 
            .packages = c("ape", "phangorn")) %do% compute.tree.dists(tree.sub.list = s.trees, 
            tree.list[[j]])
    }
    res.list <- list()
    res.list[[1]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
    for (m in 2:nrow(res.list[[1]])) {
        res.list[[1]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][1, 
            ]
    }
    rownames(res.list[[1]]) <- names(tree.list)
    colnames(res.list[[1]]) <- names(tree.list)
    res.list[[1]] <- as.dist(res.list[[1]])
    res.list[[2]] <- matrix(NA, nrow = length(tree.list), ncol = length(tree.list))
    for (m in 2:nrow(res.list[[2]])) {
        res.list[[2]][m, 1:ncol(res.par[[m]])] <- res.par[[m]][2, 
            ]
    }
    rownames(res.list[[2]]) <- names(tree.list)
    colnames(res.list[[2]]) <- names(tree.list)
    return(res.list)
}
> 
> 
> 
> cleanEx()
> nameEx("optim.edge.lengths")
> ### * optim.edge.lengths
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: optim.edge.lengths
> ### Title: This function estimates the branch lengths of a fixed tree
> ###   topology for multiple alignment data sets stored in a folder.
> ### Aliases: optim.edge.lengths
> ### Keywords: ML branch length estimation phangorn
> 
> ### ** Examples
> 
> ## Not run: 
> ##D system("mkdir optim_edge_lengths_test")
> ##D tr <- rtree(10)
> ##D 
> ##D 
> ##D setwd("./optim_edge_lengths_test")
> ##D for(i in 1:10){
> ##D 	tr.temp <- tr
> ##D 	tr.temp$edge.length <- runif(length(tr$edge.length))
> ##D 	data.temp <- as.DNAbin(simSeq(tr))
> ##D 	write.dna(data.temp, file = paste("sim_data", i, ".fasta", sep = ""), format = "fasta")
> ##D }
> ##D write.tree(tr, file = "sim_fix_tree.tre")
> ##D 
> ##D setwd("..")
> ##D 
> ##D optim.data <- optim.edge.lengths(directory = "optim_edge_lengths_test", fixed.tree = tr, model.test = TRUE)
> ##D 
> ##D par(mfrow = c(2, 5))
> ##D par(mar = c(4, 4, 4, 4))
> ##D for(i in 1:10) hist(optim.data[[1]][[i]]$edge.length, col = i, main = "", ylab = "Frequency", xlab = paste("Branch lengths for", names(optim.data[[1]])[i]))
> ##D 
> ##D dev.new()
> ##D par(mfrow = c(2, 5))
> ##D par(mar = c(4, 4, 4, 4))
> ##D for(i in 1:10){
> ##D 	plot(optim.data[[1]][[i]])
> ##D 	axisPhylo()
> ##D }
> ##D 
> ##D print(optim.data[[2]])
> ##D 
> ## End(Not run)
> ## The function is currently defined as
> function (directory, fixed.tree, form = "fasta", model.test = F, 
+     save.trees = F, tree.file.names = "output", para = F, ncore = 1) 
+ {
+     options(warn = -1)
+     directory = paste(directory, "/", sep = "")
+     file.names <- dir(directory)
+     drop.tip <- ape::drop.tip
+     file.names <- file.names[grepl(form, file.names)]
+     model.table <- matrix(NA, nrow = length(file.names), ncol = 3)
+     colnames(model.table) <- c("file", "BIC", "model")
+     model.table[, 1] <- file.names
+     data.files <- list()
+     trees.opt <- list()
+     print("reading files")
+     for (a in 1:length(file.names)) {
+         data.files[[a]] <- read.dna(paste(directory, file.names[a], 
+             sep = ""), format = form)
+     }
+     if (para == F) {
+         for (b in 1:length(file.names)) {
+             tax.keep.temp <- fixed.tree$tip.label %in% rownames(data.files[[b]])
+             trees.opt[[b]] <- drop.tip(fixed.tree, as.character(fixed.tree$tip.label[!tax.keep.temp]))
+             trees.opt[[b]]$edge.length <- rtree(nrow(data.files[[b]]))$edge.length
+             pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
+                 inv = 0, shape = 1, k = 1)
+             print(paste("model testing dataset", file.names[b], 
+                 b, "of", length(file.names)))
+             if (model.test == T) {
+             	dat.temp <- phyDat(data.files[[b]])
+ 				model.temp <- modelTest(dat.temp, multicore = T)
+                 model.table[b, 2:3] <- c(model.temp$BIC[model.temp$BIC == 
+                   min(model.temp$BIC)], model.temp$Model[model.temp$BIC == 
+                   min(model.temp$BIC)])
+                 best.model.temp <- model.temp$Model[model.temp$BIC == 
+                   min(model.temp$BIC)][1]
+             }
+             else if (model.test == F) {
+                 best.model.temp <- "JC"
+             }
+             if (length(grep("+G", best.model.temp)) == 0 && length(grep("+I", 
+                 best.model.temp)) == 0) {
+                 pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]))
+                 trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T)$tree
+             }
+             else if (length(grep("+G", best.model.temp)) == 1 && 
+                 length(grep("+I", best.model.temp)) == 0) {
+                 pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
+                   optInv = T)
+                 trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T, 
+                   optGamma = T)$tree
+             }
+             else if (length(grep("+G", best.model.temp)) == 0 && 
+                 length(grep("+I", best.model.temp)) == 1) {
+                 pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
+                   optGamma = T)
+                 trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T, 
+                   optInv = T)$tree
+             }
+             else if (length(grep("+G", best.model.temp)) == 1 && 
+                 length(grep("+I", best.model.temp)) == 1) {
+                 pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
+                   optInv = T, optGamma = T)
+                 trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T, 
+                   optGamma = T, optInv = T)$tree
+             }
+             print(paste("optimized edge lengths for tree", b, 
+                 "of", length(file.names)))
+         }
+     }
+     optim.trees.par <- function(dat) {
+         tree.par <- fixed.tree
+         dat.file <- dat
+         tax.keep.temp <- fixed.tree$tip.label %in% rownames(dat.file)
+         tree.par <- drop.tip(fixed.tree, as.character(fixed.tree$tip.label[!tax.keep.temp]))
+         lens.temp <- rtree(nrow(dat.file))
+         tree.par$edge.length <- lens.temp$edge.length
+         pml.temp <- pml(tree.par, phyDat(dat.file), inv = 0, 
+             shape = 1, k = 1)
+         if (model.test == T) {
+         	dat.temp <- phyDat(dat)
+ 			model.temp <- modelTest(dat.temp, multicore = T)
+             best.model.temp <- model.temp$Model[model.temp$BIC == 
+                 min(model.temp$BIC)][1]
+         }
+         else if (model.test == F) {
+             best.model.temp <- "JC"
+         }
+         if (length(grep("+G", best.model.temp)) == 0 && length(grep("+I", 
+             best.model.temp)) == 0) {
+             pml.temp <- pml(tree.par, phyDat(dat.file))
+             tree.par <- optim.pml(pml.temp, optEdge = T)$tree
+         }
+         else if (length(grep("+G", best.model.temp)) == 1 && 
+             length(grep("+I", best.model.temp)) == 0) {
+             pml.temp <- pml(tree.par, phyDat(dat.file), optInv = T)
+             tree.par <- optim.pml(pml.temp, optEdge = T, optGamma = T)$tree
+         }
+         else if (length(grep("+G", best.model.temp)) == 0 && 
+             length(grep("+I", best.model.temp)) == 1) {
+             pml.temp <- pml(tree.par, phyDat(dat.file), optGamma = T)
+             tree.par <- optim.pml(pml.temp, optEdge = T, optInv = T)$tree
+         }
+         else if (length(grep("+G", best.model.temp)) == 1 && 
+             length(grep("+I", best.model.temp)) == 1) {
+             pml.temp <- pml(tree.par, phyDat(dat.file), optInv = T, 
+                 optGamma = T)
+             tree.par <- optim.pml(pml.temp, optEdge = T, optGamma = T, 
+                 optInv = T)$tree
+         }
+         return(tree.par)
+     }
+     if (para == T) {
+         print("running parallel version, please wait")
+         require(doParallel)
+         require(foreach)
+         print("making clusters")
+         cl <- makeCluster(ncore)
+         registerDoParallel(cl)
+         print("clusters registered")
+         i = data.files
+         trees.opt <- foreach(dat = data.files, i = 1:length(data.files), 
+             .packages = c("phangorn", "ape")) %dopar% optim.trees.par(dat)
+         stopCluster(cl)
+         print("parallelized run complete")
+     }
+     options(warn = 1)
+     for (i in 1:length(trees.opt)) {
+         names(trees.opt)[i] <- substr(file.names[i], 1, nchar(file.names[i]) - 
+             nchar(form) - 1)
+     }
+     if (save.trees == T) {
+         print("saving trees")
+         class(trees.opt) <- "multiPhylo"
+ 		write.tree(trees.opt, file = paste(tree.file.names, ".trees", sep=""), tree.names=T)
+     }
+     class(trees.opt) <- "multiPhylo"
+     l.res <- list()
+     l.res[[1]] <- trees.opt
+     l.res[[2]] <- model.table
+     return(l.res)
+   }
function (directory, fixed.tree, form = "fasta", model.test = F, 
    save.trees = F, tree.file.names = "output", para = F, ncore = 1) 
{
    options(warn = -1)
    directory = paste(directory, "/", sep = "")
    file.names <- dir(directory)
    drop.tip <- ape::drop.tip
    file.names <- file.names[grepl(form, file.names)]
    model.table <- matrix(NA, nrow = length(file.names), ncol = 3)
    colnames(model.table) <- c("file", "BIC", "model")
    model.table[, 1] <- file.names
    data.files <- list()
    trees.opt <- list()
    print("reading files")
    for (a in 1:length(file.names)) {
        data.files[[a]] <- read.dna(paste(directory, file.names[a], 
            sep = ""), format = form)
    }
    if (para == F) {
        for (b in 1:length(file.names)) {
            tax.keep.temp <- fixed.tree$tip.label %in% rownames(data.files[[b]])
            trees.opt[[b]] <- drop.tip(fixed.tree, as.character(fixed.tree$tip.label[!tax.keep.temp]))
            trees.opt[[b]]$edge.length <- rtree(nrow(data.files[[b]]))$edge.length
            pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
                inv = 0, shape = 1, k = 1)
            print(paste("model testing dataset", file.names[b], 
                b, "of", length(file.names)))
            if (model.test == T) {
                dat.temp <- phyDat(data.files[[b]])
                model.temp <- modelTest(dat.temp, multicore = T)
                model.table[b, 2:3] <- c(model.temp$BIC[model.temp$BIC == 
                  min(model.temp$BIC)], model.temp$Model[model.temp$BIC == 
                  min(model.temp$BIC)])
                best.model.temp <- model.temp$Model[model.temp$BIC == 
                  min(model.temp$BIC)][1]
            }
            else if (model.test == F) {
                best.model.temp <- "JC"
            }
            if (length(grep("+G", best.model.temp)) == 0 && length(grep("+I", 
                best.model.temp)) == 0) {
                pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]))
                trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T)$tree
            }
            else if (length(grep("+G", best.model.temp)) == 1 && 
                length(grep("+I", best.model.temp)) == 0) {
                pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
                  optInv = T)
                trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T, 
                  optGamma = T)$tree
            }
            else if (length(grep("+G", best.model.temp)) == 0 && 
                length(grep("+I", best.model.temp)) == 1) {
                pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
                  optGamma = T)
                trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T, 
                  optInv = T)$tree
            }
            else if (length(grep("+G", best.model.temp)) == 1 && 
                length(grep("+I", best.model.temp)) == 1) {
                pml.temp <- pml(trees.opt[[b]], phyDat(data.files[[b]]), 
                  optInv = T, optGamma = T)
                trees.opt[[b]] <- optim.pml(pml.temp, optEdge = T, 
                  optGamma = T, optInv = T)$tree
            }
            print(paste("optimized edge lengths for tree", b, 
                "of", length(file.names)))
        }
    }
    optim.trees.par <- function(dat) {
        tree.par <- fixed.tree
        dat.file <- dat
        tax.keep.temp <- fixed.tree$tip.label %in% rownames(dat.file)
        tree.par <- drop.tip(fixed.tree, as.character(fixed.tree$tip.label[!tax.keep.temp]))
        lens.temp <- rtree(nrow(dat.file))
        tree.par$edge.length <- lens.temp$edge.length
        pml.temp <- pml(tree.par, phyDat(dat.file), inv = 0, 
            shape = 1, k = 1)
        if (model.test == T) {
            dat.temp <- phyDat(dat)
            model.temp <- modelTest(dat.temp, multicore = T)
            best.model.temp <- model.temp$Model[model.temp$BIC == 
                min(model.temp$BIC)][1]
        }
        else if (model.test == F) {
            best.model.temp <- "JC"
        }
        if (length(grep("+G", best.model.temp)) == 0 && length(grep("+I", 
            best.model.temp)) == 0) {
            pml.temp <- pml(tree.par, phyDat(dat.file))
            tree.par <- optim.pml(pml.temp, optEdge = T)$tree
        }
        else if (length(grep("+G", best.model.temp)) == 1 && 
            length(grep("+I", best.model.temp)) == 0) {
            pml.temp <- pml(tree.par, phyDat(dat.file), optInv = T)
            tree.par <- optim.pml(pml.temp, optEdge = T, optGamma = T)$tree
        }
        else if (length(grep("+G", best.model.temp)) == 0 && 
            length(grep("+I", best.model.temp)) == 1) {
            pml.temp <- pml(tree.par, phyDat(dat.file), optGamma = T)
            tree.par <- optim.pml(pml.temp, optEdge = T, optInv = T)$tree
        }
        else if (length(grep("+G", best.model.temp)) == 1 && 
            length(grep("+I", best.model.temp)) == 1) {
            pml.temp <- pml(tree.par, phyDat(dat.file), optInv = T, 
                optGamma = T)
            tree.par <- optim.pml(pml.temp, optEdge = T, optGamma = T, 
                optInv = T)$tree
        }
        return(tree.par)
    }
    if (para == T) {
        print("running parallel version, please wait")
        require(doParallel)
        require(foreach)
        print("making clusters")
        cl <- makeCluster(ncore)
        registerDoParallel(cl)
        print("clusters registered")
        i = data.files
        trees.opt <- foreach(dat = data.files, i = 1:length(data.files), 
            .packages = c("phangorn", "ape")) %dopar% optim.trees.par(dat)
        stopCluster(cl)
        print("parallelized run complete")
    }
    options(warn = 1)
    for (i in 1:length(trees.opt)) {
        names(trees.opt)[i] <- substr(file.names[i], 1, nchar(file.names[i]) - 
            nchar(form) - 1)
    }
    if (save.trees == T) {
        print("saving trees")
        class(trees.opt) <- "multiPhylo"
        write.tree(trees.opt, file = paste(tree.file.names, ".trees", 
            sep = ""), tree.names = T)
    }
    class(trees.opt) <- "multiPhylo"
    l.res <- list()
    l.res[[1]] <- trees.opt
    l.res[[2]] <- model.table
    return(l.res)
}
> 
> 
> 
> cleanEx()
> nameEx("run.clockstar")
> ### * run.clockstar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: run.clockstar
> ### Title: This function is wrapper for the individual ClockstaR functions.
> ###   It uses a folder that contains the individual gene alignments and the
> ###   phylogenetic tree to calculate the BSDmin distance.
> ### Aliases: run.clockstar
> ### Keywords: ~kwd1 ~kwd2
> 
> ### ** Examples
> 
> ###############
> ## Not run: 
> ##D # create folder to save some simulated data and set the working directory
> ##D initial.wd <- getwd()
> ##D system("mkdir clockstar_example")
> ##D setwd("clockstar_example")
> ##D 
> ##D #simulate trees with three different patterns of among-lineage rate variation
> ##D # see the example for the function get.all.groups for more details on these simulations.
> ##D fixed.topology <- rtree(10)
> ##D fixed.topology$edge.length <- NULL
> ##D tree.list <- list()
> ##D set.seed(1234)
> ##D patterns1 <- abs(rnorm(18, 0, 0.5))
> ##D set.seed(3456)
> ##D patterns2 <- abs(rnorm(18, 0, 0.5))
> ##D set.seed(0987)
> ##D patterns3 <- abs(rnorm(18, 0, 0.5))
> ##D for(i in 1:3){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns1 + rnorm(18, 0, 0.05))
> ##D }
> ##D 
> ##D for(i in 4:7){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns2 + rnorm(18, 0, 0.05))
> ##D }
> ##D 
> ##D for(i in 8:10){
> ##D 	tree.list[[i]] <- fixed.topology
> ##D 	tree.list[[i]]$edge.length <- abs(patterns3 + rnorm(18, 0, 0.05))
> ##D }
> ##D 
> ##D 
> ##D # Simulate sequence data along each gene tree
> ##D secs.data <- list()
> ##D for(i in 1:10){
> ##D     secs.data[[i]] <- as.DNAbin(simSeq(tree.list[[i]], l = 2000))
> ##D }
> ##D 
> ##D # Write tree and data to the folder created above
> ##D write.tree(fixed.topology, file = "simulation.tre")
> ##D 
> ##D for(i in 1:10){
> ##D     write.dna(secs.data[[i]], format = "fasta", nbcol = -1, colsep = "", file = paste("secs", i, ".fasta", sep = ""))
> ##D }
> ##D ##############
> ##D # Run clockstar using the simulated data in manual mode
> ##D #run.clockstar.mod(files.directory = "", out.file.name = "", para = F, ncore = 1, model.test = F, mode.run = "", k.man = 2, k.max, ...)
> ##D 
> ##D run.clockstar(files.directory = getwd(), out.file.name = "clockstar_test_out", mode.run = "a")
> ##D 
> ##D # See the results in the "clockstar_test_out" folder
> ##D setwd(initial.wd)
> ##D 
> ## End(Not run)
> 
> ## The function is currently defined as
> run.clockstar <-
+ function(files.directory = "", out.file.name = "", para = F, ncore = 1, model.test = F, mode.run = "", k.man = 2, k.max, ...){
+ 	while(files.directory == ""){	
+ 		print("Please select the file with the sequence data and the phylogenetic tree ")
+ 		files.directory <- tk_choose.dir(caption = "Select the folder with the data")
+ 	}
+ 	if	(length(grep("tre|fasta|nex*", dir(files.directory))) == 0){
+ 		stop("There are no tree, fasta, or nexus files in the directory. Please make sure the files have the .tre, .fasta, or .nex ")
+ 	}
+ 	if	(out.file.name == ""){
+ 		out.file.name <- readline("Please give a name for the results file (default is clockstar.output): ")
+ 		if(out.file.name == ""){
+ 			out.file.name <- "clockstar.output"
+ 		}
+ 	}
+     while (mode.run == "") {
+         mode.run <- readline("Run clockstar in automatic or manual mode (type 'a' or 'm')? ")
+         if (mode.run == "m") {
+             k.man <- readline("Please input a value for k : ")
+             k.man <- as.numeric(k.man)
+             while (!is.numeric(k.man)) {
+                 k.man <- readline("Please input a NUMERIC value for k : ")
+             }
+             print(paste("you have selected a k of: ", k.man))
+         }
+         if (mode.run == "a") {
+             print("ClockstaR will run in automatic mode")
+         }
+     }
+     files <- dir(files.directory)
+     files.format <- files[!(grepl(".tre", files) | grepl(out.file.name, 
+         files))][1]
+     files.format <- substr(files.format, regexpr("[.]", files.format)[1] + 
+         1, nchar(files.format))
+     if (files.format == "nex") {
+         convert.to.fasta(files.directory)
+     }
+     init.dir <- getwd()
+     setwd(files.directory)
+     if (any(dir() == out.file.name)) {
+         delete.files <- NA
+         while (!(delete.files %in% c("Y", "y", "N", "n"))) {
+             delete.files <- readline("A clockstar run with the same output name already exists in this folder. Overwrite? (y/n) ")
+         }
+         if (delete.files %in% c("Y", "y")) {
+             if (Sys.info()[1] == "Windows") {
+                 shell(paste("rm -rf", out.file.name))
+                 shell(paste("mkdir", out.file.name))
+             }
+             else {
+                 system(paste("rm -rf", out.file.name))
+                 system(paste("mkdir", out.file.name))
+             }
+             setwd(out.file.name)
+         }
+         else {
+             new.dir <- paste(out.file.name, length(grep(out.file.name, 
+                 dir())) + 1, sep = "")
+             if (Sys.info()[1] == "Windows") {
+                 shell(paste("mkdir ", new.dir, sep = ""))
+             }
+             else {
+                 system(paste("mkdir ", new.dir, sep = ""))
+             }
+             setwd(new.dir)
+         }
+     }
+     else {
+         if (Sys.info()[1] == "Windows") {
+             shell(paste("mkdir", out.file.name))
+         }
+         else {
+             system(paste("mkdir", out.file.name))
+         }
+         setwd(out.file.name)
+     }
+     fix.tree <- read.tree(paste(files.directory, files[grep(".tre", 
+         files)[1]], sep = "/"))
+     fix.tree$edge.length <- runif(length(fix.tree$tip.label) * 
+         2 - 1)
+     print("OPTIMISING BRANCH LENGTHS")
+     opt.trees <- optim.edge.lengths(files.directory, fix.tree, 
+         save.trees = TRUE, model.test = model.test, tree.file.names = "optimized", 
+         para = para, ncore = ncore)
+     write.table(opt.trees[[2]], file = "models.csv", sep = ",", 
+         row.names = FALSE)
+     opt.trees.only <- opt.trees[[1]]
+     print("FINISHED OPTIMISING BRANCH LENGTHS")
+     print("CALCULATING BSD")
+     if (para == F) {
+         bsd.matrix <- min.dist.topo.mat(opt.trees.only)
+     }
+     else if (para == T) {
+         bsd.matrix <- min.dist.topo.mat.para(opt.trees.only, 
+             para = T, ncore = ncore)
+     }
+     print("FINISHED CALCULATING BSD")
+     write.table(as.matrix(bsd.matrix[[1]]), file = "bsd.distances.csv", 
+         sep = ",")
+     write.table(as.matrix(bsd.matrix[[2]]), file = "scaling.factors.csv", 
+         sep = ",")
+     if (ncol(bsd.matrix[[2]]) > 2) {
+         bsd.dendrogram <- nj(bsd.matrix[[1]])
+         write.tree(bsd.dendrogram, file = "bsd.dendrogram.tre")
+     }
+     else if (ncol(bsd.matrix[[2]]) == 2) {
+         bsd.matrix[[1]] <- as.matrix(bsd.matrix[[1]])
+         bsd.matrix[[1]] <- cbind(c(0.5, 0.5), bsd.matrix[[1]])
+         bsd.matrix[[1]] <- rbind(c(0.5, 0.5, 0.5), bsd.matrix[[1]])
+         colnames(bsd.matrix[[1]])[1] <- 3
+         rownames(bsd.matrix[[1]])[1] <- 3
+         bsd.matrix[[1]] <- as.dist(bsd.matrix[[1]])
+         bsd.dendrogram <- nj(bsd.matrix[[1]])
+         bsd.dendrogram <- drop.tip(bsd.dendrogram, "3")
+         write.tree(bsd.dendrogram, file = "bsd.dendrogram.tre")
+     }
+     else {
+         print("ERROR IN DENDROGRAM OF TREE DISTANCES")
+     }
+     bsd.data <- as.matrix(bsd.matrix[[1]])
+     print("CALCULATING NUMBER OF GROUPS")
+     if (mode.run == "a") {
+         print(paste("running in automatic mode"))
+         print(bsd.data)
+         parts <- get.all.groups(bsd.data, save.partitions = T, ...)
+         diagnostics.output <- diagnostics.clockstar(parts, save.plots = TRUE, interactive = FALSE, ...)
+     }
+     else if (mode.run == "m") {
+         print(paste("running manual mode with k =", k.man))
+         parts <- get.all.groups.k(bsd.data, k = k.man, save.partitions = T)
+     }
+     print("FINISHED CALCULATING NUMBER OF GROUPS")
+     print("PLOTTING")
+     if (mode.run == "a"){
+ 		parts.pre <- parts
+ 		parts <- parts[[1]]
+ 	}
+     pdf("bsd.plots.pdf")
+     par(mfrow = c(3, 1))
+     hist(bsd.data, xlab = expression(italic(sBSDmin)), main = expression(italic(sBSDmin)), 
+         freq = T)
+     k.expe.vec <- vector()
+     k.expe.names <- vector()
+     for (i in 1:length(parts)) {
+         k.expe.vec <- c(k.expe.vec, parts[[i]])
+         k.expe.names <- c(k.expe.names, rep(names(parts)[i], 
+             length(parts[[i]])))
+     }
+     k.expe.names <- as.numeric(as.factor(k.expe.names))
+     k.matrix <- k.expe.names
+     names(k.matrix) <- k.expe.vec
+     image(t(as.matrix(k.matrix)), axes = F, col = rainbow(length(k.matrix)), 
+         main = "Partition assignments (Colour represents individual partitions)")
+     mtext(text = names(k.matrix), side = 2, line = 0.3, at = seq(0, 
+         1, 1/(length(k.matrix) - 1)), las = 1, cex = 0.8)
+     plot(bsd.dendrogram, "unrooted")
+     dev.off()
+     
+     if (mode.run=="m") {
+ 		parts.pre <- get.all.groups(bsd.data, pam.results = TRUE, ...)
+ 		diagnostics.output <- diagnostics.clockstar(parts.pre, save.plots = TRUE, interactive = FALSE, ...)
+ 	} else {
+ 		diagnostics.output <- diagnostics.clockstar(parts.pre, save.plots = TRUE, interactive = FALSE, ...)
+ 	}
+     
+     setwd(init.dir)
+     print("FINISHED RUN")
+   }
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> ### * <FOOTER>
> ###
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  10.46 3.606 13.482 0 0.001 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
